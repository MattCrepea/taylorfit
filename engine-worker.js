!function(){this.global=this,this.window=this}(),function(n){function t(a){if(e[a])return e[a].exports;var r=e[a]={exports:{},id:a,loaded:!1};return n[a].call(r.exports,r,r.exports,t),r.loaded=!0,r.exports}var e={};return t.m=n,t.c=e,t.p="",t(0)}([/*!********************************!*\
  !*** ./engine/worker/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("/*global onmessage, postMessage*/\n'use strict';\n\nvar singleton = __webpack_require__(/*! ../model/singleton */ 1).getInstance();\nvar cache     = {};\n\nconst cacheKeys = ['dataset', 'dependent', 'exponents', 'multiplicands'];\n\nvar updateCache = function (data) {\n  cacheKeys.forEach(\n    (key) => cache[key] = (data[key] != null) ? data[key] : cache[key]\n  );\n};\n\n/**\n * Updates the model in various ways depending on what's given.\n *\n * NOTE: Some the parameters are *REQUIRED* (non-bracketed). These must\n * be given in every call to this function.\n *\n * @param {number[][]}       [data.model] See Model.constructor (arg X)\n * @param {number[]}       data.exponents See Model.constructor\n * @param {number}     data.multiplicands See Model.constructor\n * @param {number}         data.dependent Column index of dependent variable\n * @param {[number, number[]]} [data.row] Pair of (index, [number]) specifying\n *                                        the row index to replace and the data\n *                                        that replaces it\n * @param {[number, number[]]} [data.col] Pair of (index, [number]) specifying\n *                                        the col index to replace and the data\n *                                        that replaces it\n * @param {[numr, num, num]}  [data.item] Triple of (row, col, value) that\n *                                        specify a location and value to\n *                                        replace\n */\nvar updateModel = function (data) {\n  var dataset       = data.dataset || (model && model.X) || cache.dataset\n    , existingTerms = (model && model.terms.map((t) => t.term)) || []\n    , dependent     = (data.dependent != null) ? data.dependent : cache.dependent\n    , exponents     = data.exponents || cache.exponents\n    , multiplicands = data.multiplicands || cache.multiplicands\n    , row           = data.row\n    , col           = data.col\n    , item          = data.item\n    , i;\n\n  log('mults ' + multiplicands);\n\n  if (dataset == null) {\n    throw new TypeError('dataset must be specified');\n  }\n  if (dependent == null) {\n    throw new TypeError('dependent must be specified');\n  }\n  if (exponents == null) {\n    throw new TypeError('exponents must be specified');\n  }\n  if (multiplicands == null) {\n    throw new TypeError('multiplicands must be specified');\n  }\n\n  // Replace the row if requested\n  if (row != null) {\n    dataset.row(row[0], row[1]);\n  }\n\n  // Replace the col if requested\n  if (col != null) {\n    dataset.col(col[0], col[1]);\n  }\n\n  // Replace all items requested\n  if (item != null) {\n    item.forEach((it) => {\n      dataset.set(it[0], it[1], it[2]);\n    });\n  }\n\n  // Reinstantiate the model\n  model = engine.model(dataset, dependent, exponents, multiplicands);\n  existingTerms.forEach((term) => model.addTerm(term));\n\n  return model;\n};\n\n\n/**\n * Takes the computed candidate terms produced by the model and formats them to\n * conform to the data contract (what the client is expecting).\n *\n * Input:\n * [\n *   {\n *     term: [ [col, exp], [col, exp], ... ],\n *     stats: { t: 0.12, mse: 0.45 }\n *   },\n *   ...\n * ]\n *\n *\n * Output:\n * [\n *   [ col, exp, col, exp, ..., tstat: 0.12, mse: 0.25 ], // candidate term 0\n *   [ col, exp, col, exp, ..., tstat: 0.02, mse: 0.45 ], // candidate term 1\n *   ...\n * ]\n *\n * @param candidates See 'Input' above\n * @return See 'Output' above\n */\nvar formatCandidates = function (candidates) {\n  return candidates.map((candidate) => {\n    var newCandidate = [];\n\n    candidate.term.forEach(\n      (multiplicand) => newCandidate.push(multiplicand[0], multiplicand[1])\n    );\n    newCandidate.t = candidate.stats.t;\n    newCandidate.mse = candidate.stats.mse;\n\n    return newCandidate;\n  });\n};\n\n\nvar log = function () {\n  console.debug('[Engine]:', ...arguments);\n};\n\nonmessage = function (e) {\n  var type = e.data.type\n    , data = e.data.data;\n\n  log(e.data);\n\n  switch(type) {\n\n  case 'update':\n    //updateCache(data);\n    //updateModel(data);\n    if (data.dataset != null) {\n      singleton.setDataset(data.dataset);\n    }\n    if (data.exponents != null) {\n      singleton.setExponents(data.exponents);\n    }\n    if (data.multiplicands != null) {\n      singleton.setMultiplicands(data.multiplicands);\n    }\n    if (data.dependent != null) {\n      singleton.setDependent(data.dependent);\n    }\n\n    log('new model:', singleton.model);\n\n    postMessage({\n      type: 'candidates',\n      data: singleton.model.compute().candidates\n    });\n    break;\n\n  case 'get_terms':\n    postMessage({\n      type: 'candidates',\n      data: singleton.model.compute().candidates\n    });\n    break;\n\n  case 'add_term':\n    singleton.model.addTerm(data, false);\n\n    let updatedModel = singleton.model.compute();\n\n    postMessage({\n      type: 'candidates',\n      data: updatedModel.candidates\n    });\n    postMessage({\n      type: 'model',\n      data: updatedModel.model\n    });\n    break;\n\n  case 'remove_term':\n    singleton.model.removeTerm(data, false);\n    // This should also eventually send candidates and model\n    postMessage({\n      type: 'candidates',\n      data: singleton.model.compute().candidates\n    });\n    break;\n\n  default:\n    postMessage({ type: 'error', data: 'Invalid type: ' + type });\n\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/index.js\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./engine/worker/index.js?")},/*!***********************************!*\
  !*** ./engine/model/singleton.js ***!
  \***********************************/
function(module,exports,__webpack_require__){eval("\n\nconst utils     = __webpack_require__(/*! ../utils */ 2);\nconst Matrix    = __webpack_require__(/*! ../matrix */ 3).Matrix;\nconst Model     = __webpack_require__(/*! ./model */ 8);\n\nconst defaults  = {\n  dataset       : new Matrix(0, 0),\n  dependent     : 0,\n  exponents     : [1],\n  multiplicands : 1\n};\n\n\nlet instance = null;\n\n/**\n * Singleton which maintains a single Model instance and keeps track of the\n * parameters for the model -- exponents, multiplicands, ... . When one of these\n * parameters is updated, the model is reinstantiated.\n *\n * XXX: Consider updating the model instead of replacing it. This will make\n * things easier by saving terms already in the model.\n *\n * @class SingletonModel\n */\nclass SingletonModel {\n\n  constructor() {\n    if (instance) {\n      return instance;\n    }\n\n    for (let property in defaults) {\n      this[property] = defaults[property];\n    }\n\n    this.update();\n\n    return instance = this;\n  }\n\n  static getInstance() {\n    if (!instance) {\n      instance = new SingletonModel();\n    }\n    return instance;\n  }\n\n  static reset() {\n    instance = null;\n    return new SingletonModel();\n  }\n\n  getX() {\n    var inputColumnRange = [].concat(\n      utils.range(0, this.dependent),\n      utils.range(this.dependent + 1, this.dataset.shape[1])\n    );\n\n    return this.dataset.subset(':', inputColumnRange);\n  }\n\n  gety() {\n    return this.dataset.col(this.dependent);\n  }\n\n  update() {\n    return this.model = new Model(\n      this.getX(),\n      this.gety(),\n      this.exponents,\n      this.multiplicands\n    );\n  }\n\n  setExponents(exponents) {\n    if (!Array.isArray(exponents)) {\n      throw new TypeError('exponents must be an array of numbers');\n    }\n    exponents.forEach((exp) => {\n      if (typeof exp !== 'number') {\n        throw new TypeError('exponents must be an array of numbers');\n      }\n    });\n\n    this.exponents = exponents;\n    this.update();\n    return this;\n  }\n\n  setMultiplicands(multiplicands) {\n    if (typeof multiplicands !== 'number' || multiplicands % 1 !== 0) {\n      throw new TypeError('multiplicands must be an integer');\n    }\n\n    this.multiplicands = multiplicands;\n    this.update();\n    return this;\n  }\n\n  setDependent(dependent) {\n    if (typeof dependent !== 'number' || dependent % 1 !== 0) {\n      throw new TypeError('dependent must be an integer');\n    }\n    if (dependent < 0 || dependent >= this.dataset.shape[1]) {\n      throw new RangeError('depdendent column is out of range: ' +\n                           dependent + ' not in [' + 0 + ', ' +\n                           this.dataset.shape[1] + ']');\n    }\n\n    this.dependent = dependent;\n    this.update();\n    return this;\n  }\n\n  setDataset(dataset) {\n    this.dataset = new Matrix(dataset);\n    this.dependent = defaults.dependent;\n    this.update();\n    return this;\n  }\n\n}\n\n\nmodule.exports = SingletonModel;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/singleton.js\n// module id = 1\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/singleton.js?")},/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
function(module,exports){eval("\nfunction nspaces(n) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(' ');\n}\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - (''+val).length) + val;\n}\n\n\nmodule.exports.range = (start, end) => {\n  if (start >= end) {\n    return [];\n  }\n  return Array(end - start).join(' ').split(' ').map((_, i) => i + start);\n};\n\nmodule.exports.convertRange = (str, length) => {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return (str < 0) ? [length + str] : [str];\n  }\n  if (typeof str !== 'string') {\n    return str.map((ind) => (ind < 0) ? length + ind : ind);\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n    if (end < 0) {\n      end = length + end;\n    }\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = (leftwidth, rightwidth, val) => {\n  val = ''+val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/)\n    , whole = match[1]\n    , frac = match[2]\n    , repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n  repr += nspaces(leftwidth - whole.length) + whole;\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nspaces(rightwidth - frac.length);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n  return repr;\n};\n\nmodule.exports.padAll = (lwidth, str) => {\n  if (Array.isArray(str)) {\n    return str.map((s) => module.exports.padAll(lwidth + s.length, s));\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map((s) => pad(lwidth + s.length, s)).join('\\n');\n  }\n  return pad(lwidth, str);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 2\n// module chunks = 0\n//# sourceURL=webpack:///./engine/utils.js?")},/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("\n// lstsqSVD | lstsqNE\nconst METHOD = 'lstsqSVD';\n\nmodule.exports.Matrix = __webpack_require__(/*! ./matrix */ 4);\nmodule.exports.svd    = __webpack_require__(/*! ./svd-golub-reinsch */ 5);\nmodule.exports.lstsq  = __webpack_require__(/*! ./lstsq */ 6)[METHOD];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 3\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/index.js?")},/*!*********************************!*\
  !*** ./engine/matrix/matrix.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("\nconst utils = __webpack_require__(/*! ../utils */ 2);\n\n/**\n * Private members\n *\n * @private\n */\nconst _data = Symbol('data');\nconst _m    = Symbol('m');\nconst _n    = Symbol('n');\n\n// Maximum number of decimal points to print\nconst PRINT_DECIMALS = 5;\n\n// Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\nconst MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Swap rows `i` and `j` in matrix `m` in place.\n *\n * @param {Matrix} m\n * @param {number} i\n * @param {number} j\n */\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n\n/**\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n\n/**\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n\n\n/**\n * A speedy 2-dimensional matrix implementation.\n *\n * @class Matrix\n */\nclass Matrix {\n\n  /**\n   * Creates a new Matrix of size <n, m>, using `stuff`.\n   *\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\n   * its contents will be copied into a new Float64Array.\n   *\n   * @param {number | number[][]}       n     Number of rows (or nested arrays\n   *                                          that look like a matrix)\n   * @param {number}                    m     Number of columns\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\n   */\n  constructor(m, n, stuff) {\n    if (m instanceof Matrix) {\n      return m;\n    }\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n    if (stuff != null) {\n      stuff = (stuff instanceof Float64Array)\n              ? stuff\n              : Float64Array.from(stuff);\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    }\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n\n  /**\n   * Retrieve the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @return {number} Element at (i, j)\n   */\n  get(i, j) {\n    return this[_data][i * this[_n] + j];\n  }\n\n  /**\n   * Set the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @param {number} value To replace the existing one\n   * @return {number} Element at (i, j)\n   */\n  set(i, j, value) {\n    return this[_data][i * this[_n] + j] = value;\n  }\n\n  /**\n   * Performs element-wise addition between two matrices and returns a new copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this + other\n   * @throws {Error} If dimensions do not match\n   */\n  add(other) {\n    var sum = this.clone()\n      , i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape +\n                        ') and (' + other.shape + ') do not match: ' +\n                        this[_n] + ' !== ' + other[_m] + ' && ' +\n                        this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs element-wise subtraction between two matrices and returns a new\n   * copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this - other\n   * @throws {Error} If dimensions do not match\n   */\n  sub(other) {\n    var sum = this.clone()\n      , i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape +\n                        ') and (' + other.shape + ') do not match: ' +\n                        this[_n] + ' !== ' + other[_m] + ' && ' +\n                        this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs matrix multiplication between this and other.\n   *\n   * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\n   * @return {Matrix<m,k>} this * other\n   * @throws {Error} If dimensions do not match\n   */\n  dot(other) {\n    if (this[_n] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape +\n                      ') and (' + other.shape + ') do not match: ' +\n                      this[_n] + ' !== ' + other[_m]);\n    }\n\n    var product = new Matrix(this[_m], other[_n])\n      , i, j, k, sum;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < other[_n]; j += 1) {\n        for (k = 0, sum = 0; k < this[_n]; k += 1) {\n          sum += this[_data][i * this[_n] + k] *\n                 other[_data][k * other[_n] + j];\n        }\n        product[_data][i * other[_n] + j] = sum;\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Computes the inverse of the matrix (only if it is square!).\n   *\n   * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\n   * @throws {Error} If not a square matrix\n   */\n  inv() {\n    if (this[_m] !== this[_n]) {\n      throw new Error('Must be square');\n    }\n\n    var self = this.clone()\n      , inverse = Matrix.eye(this[_m], this[_n])\n      , i, j, k, factor;\n\n    for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n      if (self[_data] === 0) {\n        for (\n          k = 0;\n          self[_data][k * self[_n] + j] !== 0 && k < self[_m];\n          k += 1\n        )\n          ;\n        if (k >= self[_m]) {\n          j += 1;\n          continue;\n        }\n        swapRows(self, j, k);\n        swapRows(inverse, j, k);\n      }\n      divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n      subtractRowMultiple(self, inverse, i, j);\n    }\n    return inverse;\n  }\n\n  /**\n   * Returns a copy of the matrix.\n   *\n   * @return {Matrix<m,n>} Fresh clone\n   */\n  clone() {\n    return new Matrix(this[_m], this[_n], this[_data].slice());\n  }\n\n  /**\n   * Horizontally stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<m,k>} other Matrix whose rows === this's rows\n   * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  hstack(other) {\n    if (this[_m] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape +\n                      ') and (' + other.shape + ') do not match: ' +\n                      this[_m] + ' !== ' + other[_m]);\n    }\n\n    var newM = this[_n] + other[_n]\n      , stacked = new Matrix(this[_m], newM)\n      , i, j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        stacked[_data][i*newM + j] = this[_data][i*this[_n] + j];\n      }\n      for (j = 0; j < other[_n]; j += 1) {\n        stacked[_data][i*newM + this[_n]+j] = other[_data][i*other[_n] + j];\n      }\n    }\n    return stacked;\n  }\n\n  /**\n   * Vertically stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<k,n>} other Matrix whose cols === this's cols\n   * @return {Matrix<m+k,n>} Vertical concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  vstack(other) {\n    if (this[_n] !== other[_n]) {\n      throw new Error('Dimensions (' + this.shape +\n                      ') and (' + other.shape + ') do not match: ' +\n                      this[_n] + ' !== ' + other[_n]);\n    }\n\n    var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n    stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n    stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n    return stacked;\n  }\n\n  /**\n   * Performs element-wise exponentiation to the matrix and returns a new copy.\n   *\n   * @param {number} exponent Power to raise each element to\n   * @return {Matrix<m,n>} this[i,i]^exponent\n   */\n  dotPow(exponent) {\n    var powd = this.clone()\n      , i;\n\n    for (i = 0; i < powd[_data].length; i += 1) {\n      powd[_data][i] = Math.pow(powd[_data][i], exponent);\n      if (!Number.isFinite(powd[_data][i])) {\n        powd[_data][i] = MAX_SAFE_INTEGER;\n      }\n    }\n    return powd;\n  }\n\n  /**\n   * Performs element-wise multiplication to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Multiplicand to multiply each element by, or a\n   *                            matrix whose elements will be iterated through\n   *                            in alignment with this\n   * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\n   */\n  dotMultiply(n) {\n    var product = this.clone()\n      , i;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n[_data][i];\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Performs element-wise division to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Divisor to divide each element by, or a matrix\n   *                            whose elements will be iterated through in\n   *                            alignment with this\n   * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\n   */\n  dotDivide(n) {\n    var product = this.clone()\n      , i, j;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] / n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n        if (j >= n[_data].length) {\n          j = 0;\n        }\n        product[_data][i] = product[_data][i] / n[_data][j];\n      }\n    }\n    return product;\n  }\n\n  /**\n   * @see inspect\n   */\n  toString() {\n    return this.inspect();\n  }\n\n  /**\n   * Stringifies the matrix into a pretty format\n   *\n   * @return {string} Representation of the matrix\n   */\n  inspect(depth, options={ stylize: (x) => ''+x }) {\n    var repr = options.stylize(this.constructor.name, 'none')\n      , strings = Array.from(this[_data])\n          .map((i) => (''+i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/))\n      , lwidth = Math.max.apply(null, strings.map((match) => match[1].length))\n      , rwidth = Math.min(\n          Math.max.apply(null, strings.map((match) => match[2].length)),\n          PRINT_DECIMALS\n        )\n      , rows = []\n      , i;\n\n    strings = Array.from(this[_data]).map(\n      (n) => options.stylize(utils.formatNum(lwidth, rwidth, n), 'number')\n    );\n\n    for (i = 0; i < this[_m]; i += 1) {\n      rows.push('[ ' + strings.slice(i*this[_n], (i+1)*this[_n]).join(', ') + ' ]');\n    }\n\n    return repr + ' ' + utils.padAll(\n      this.constructor.name.length + 1,\n      rows.join('\\n')\n    ).trim();\n  }\n\n  /**\n   * Retrieves/sets the ith column of the matrix\n   *\n   * @param {number}    i         Column index\n   * @param {number[]}  [newCol]  Elements to replace the col with\n   * @return {Matrix<m,1>} Column as a matrix\n   */\n  col(i, newCol) {\n    var theCol = new Matrix(this[_m], 1)\n      , k;\n\n    if (newCol != null) {\n      if (newCol.length > this[_m]) {\n        throw new RangeError('newCol cannot be longer than ' + this[_m]);\n      }\n      for (k = 0; k < this[_m]; k += 1) {\n        this[_data][k * this[_n] + i] = newCol[k];\n      }\n    }\n\n    for (k = 0; k < this[_m]; k += 1) {\n      theCol[_data][k] = this[_data][k * this[_n] + i];\n    }\n    return theCol;\n  }\n\n  /**\n   * Retrieves/sets the ith row of the matrix\n   *\n   * @param {number}    i         Row index\n   * @param {number[]}  [newRow]  Elements to replace the row with\n   * @return {Matrix<1,n>} Row as a matrix\n   */\n  row(i, newRow) {\n    if (newRow != null) {\n      if (newRow.length > this[_n]) {\n        throw new RangeError('newRow cannot be longer than ' + this[_n]);\n      }\n      this[_data].subarray(i * this[_n]).set(newRow);\n    }\n    return new Matrix(\n      1, this[_n],\n      this[_data].slice(i * this[_n], (i+1) * this[_n])\n    );\n  }\n\n  /**\n   * Retrieves a subset of the matrix, constructed from indices in `rows` and\n   * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\n   * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\n   *\n   * @param {number[]} rows Array of indices used to construct the subset\n   * @param {number[]} cols Array of indices used to construct the subset\n   * @return {Matrix<rows.length, cols.length>} Subset of this\n   */\n  subset(rows, cols) {\n    rows = utils.convertRange(rows, this[_m]);\n    cols = utils.convertRange(cols, this[_n]);\n\n    var subMatrix = new Matrix(rows.length, cols.length)\n      , i, j;\n\n    for (i = 0; i < rows.length; i += 1) {\n      for (j = 0; j < rows.length; j += 1) {\n        subMatrix[_data][i * subMatrix[_n] + j] =\n          this[_data][rows[i] * this[_n] + cols[j]];\n      }\n    }\n    return subMatrix;\n  }\n\n  /**\n   * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\n   *\n   * @return {Matrix<1,min(m,n)>} Diagonal elements\n   */\n  diag() {\n    var diagonal = new Matrix(1, Math.min(this[_m], this[_n]))\n      , i;\n\n    for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n      diagonal[_data][i] = this[_data][i * this[_n] + i];\n    }\n    return diagonal;\n  }\n\n  /**\n   * Performs `Math.abs()` on each element then returns the resulting matrix.\n   *\n   * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\n   *                       each element\n   */\n  abs() {\n    var absolute = this.clone()\n      , i;\n\n    for (i = 0; i < absolute[_data].length; i += 1) {\n      absolute[_data][i] = Math.abs(absolute[_data][i]);\n    }\n    return absolute;\n  }\n\n  /**\n   * Sums all of the elements.\n   *\n   * @return {number} Sum of all of the elements\n   */\n  sum() {\n    var tot = 0\n      , i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot += this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\n   * @property {Matrix<n,m>} T The transposition of the matrix\n   */\n  get T() {\n    var transpose = new Matrix(this[_n], this[_m])\n      , i, j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n      }\n    }\n    return transpose;\n  }\n\n  /**\n   * @property {[number, number]} shape The shape of this matrix [m, n]\n   */\n  get shape() {\n    return [this[_m], this[_n]];\n  }\n\n  /**\n   * @property {Float64Array} data The underlying storage for the matrix\n   */\n  get data() {\n    return this[_data];\n  }\n\n  /**\n   * Generates a matrix full of random (0, 1) numbers.\n   *\n   * @static\n   * @return {Matrix<m,n>} Matrix full'a random numbas\n   */\n  static random(m, n) {\n    var randMatrix = new Matrix(m, n)\n      , i, j;\n\n    for (i = 0; i < m; i += 1) {\n      for (j = 0; j < n; j += 1) {\n        randMatrix[_data][i * n + j] = Math.random();\n      }\n    }\n    return randMatrix;\n  }\n\n  /**\n   * Generates a matrix whose diagonal elements equal 1.\n   *\n   * @static\n   * @return {Matrix<m,n>} Diagonal onez\n   */\n  static eye(m, n=m) {\n    var onez = new Matrix(m, n)\n      , i, j;\n\n    for (i = 0; i < m; i += 1) {\n      onez[_data][i * n + i] = 1;\n    }\n    return onez;\n  }\n\n  /**\n   * Creates a matrix from matrix-looking nested arrays, or a flat array and the\n   * given `m` and `n`.\n   *\n   * @param {iterable | Matrix} arr Values to populate the matrix with\n   * @param {number}            m   Rows in the new matrix\n   * @param {number}            n   Columns in the new matrix\n   */\n  static from(arr, m, n) {\n    if (arr instanceof Matrix) {\n      return arr.clone();\n    }\n    if (!Array.isArray(arr)) {\n      throw new TypeError('Expected an array or Matrix');\n    }\n    if (arr.length <= 0) {\n      return new Matrix(0, 0);\n    }\n\n    var i;\n\n    m = m || arr.length;\n    n = n || arr[0].length;\n\n    // handed a 1-d array\n    if (arr[0].length == null) {\n      return new Matrix(1, arr.length, Float64Array.from(arr));\n    }\n\n    // otherwise, it's a 2-d array (and hopefully not >2-d)\n    for (i = 0; i < arr.length; i += 1) {\n      if (arr[i].length !== n) {\n        throw new Error('All rows must have equal length');\n      }\n    }\n    return new Matrix(m, n, Float64Array.from([].concat.apply([], arr)));\n  }\n\n  /**\n   * Creates a matrix using `arr` to fill the diagonal elements in order.\n   *\n   * @param {number[m]} arr Array of numbers\n   * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\n   */\n  static diag(arr) {\n    var m = arr.length\n      , mat = new Matrix(m, m)\n      , i;\n\n    for (i = 0; i < m; i += 1) {\n      mat.data[i*m+i] = arr[i];\n    }\n    return mat;\n  }\n\n}\n\nmodule.exports = Matrix;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/matrix.js\n// module id = 4\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/matrix.js?")},/*!********************************************!*\
  !*** ./engine/matrix/svd-golub-reinsch.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst Matrix  = __webpack_require__(/*! ./matrix */ 4);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a)\n    , absb = Math.abs(b);\n\n  return (absa > absb\n          ? absa * Math.sqrt(1 + Math.pow(absb/absa, 2))\n          : (absb === 0 ? 0 : absb*Math.sqrt(1 + Math.pow(absa/absb, 2))));\n}\n\n/**\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\n * by G. H. Golub and C. Reinsch.\n *\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\n *\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\n */\nfunction svd(A) {\n  var eps = Number.EPSILON\n    , tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50\n    , u = A.clone()\n    , m = u.shape[0]\n    , n = u.shape[1]\n    , e = []\n    , q = []\n    , v = new Matrix(n, n)\n    , g = 0.0\n    , x = 0.0\n    , i, j, k, l, s, f, h, y, iteration, gotoTestFConvergence, z, c, l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n    for (j = i; j < m; j++) s += u.data[j*n+i]*u.data[j*n+i];\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i*n+i];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f*g-s;\n      u.data[i*n+i] = f-g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = i; k < m; k++) s += u.data[k*n+i]*u.data[k*n+j];\n        f = s/h;\n        for (k = i; k < m; k++) u.data[k*n+j] = u.data[k*n+j] + f*u.data[k*n+i];\n      }\n    }\n    q[i] = g;\n    s = 0.0;\n    for (j = l; j < n; j++) s = s + u.data[i*n+j]*u.data[i*n+j];\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i*n+i+1];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f*g - s;\n      u.data[i*n+i+1] = f-g;\n      for (j = l; j < n; j++) e[j] = u.data[i*n+j]/h;\n      for (j = l; j < m; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s = s + (u.data[j*n+k]*u.data[i*n+k]);\n        for (k = l; k < n; k++) u.data[j*n+k] = u.data[j*n+k]+(s*e[k]);\n      }\n    }\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n    if (y > x) {\n      x = y;\n    }\n  }\n  // accumulation of right hand transformations\n  for (i = n-1; i > -1; i--) {\n    if (g !== 0) {\n      h = g*u.data[i*n+i+1];\n      for (j = l; j < n; j++) v.data[j*n+i] = u.data[i*n+j]/h;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s += (u.data[i*n+k]*v.data[k*n+j]);\n        for (k = l; k < n; k++) v.data[k*n+j] += (s*v.data[k*n+i]);\n      }\n    }\n    for (j = l; j < n; j++) {\n      v.data[i*n+j] = 0.0;\n      v.data[j*n+i] = 0.0;\n    }\n    v.data[i*n+i] = 1.0;\n    g = e[i];\n    l = i;\n  }\n  // accumulation of left hand transformations\n  for (i = n-1; i > -1; i--) {\n    l = i+1;\n    g = q[i];\n    for (j = l; j < n; j++) u.data[i*n+j] = 0.0;\n    if (g !== 0.0) {\n      h = u.data[i*n+i]*g;\n      for (j = l; j < n; j++)  {\n        s = 0.0;\n        for (k = l; k < m; k++) s += (u.data[k*n+i]*u.data[k*n+j]);\n        f = s/h;\n        for (k = i; k < m; k++) u.data[k*n+j] += (f*u.data[k*n+i]);\n      }\n      for (j = i; j < m; j++) u.data[j*n+i] = u.data[j*n+i] / g;\n    } else {\n      for (j = i; j < m; j++) u.data[j*n+i] = 0.0;\n    }\n    u.data[i*n+i] += 1.0;\n  }\n  // diagonalization of the bidiagonal form\n  eps = eps*x;\n  for (k = n-1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n        if (Math.abs(q[l-1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l-1;\n        for (i = l; i < k+1; i++) {\n          f = s*e[i];\n          e[i] = c*e[i];\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g/h;\n          s = -f/h;\n          for (j = 0; j < m; j++) {\n            y = u.data[j*n+l1];\n            z = u.data[j*n+i];\n            u.data[j*n+l1] = y*c+z*s;\n            u.data[j*n+i] = -y*s+z*c;\n          }\n        }\n      }\n      // test f convergence\n      z = q[k];\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n          for (j = 0; j < n; j++) {\n            v.data[j*n+k] = -v.data[j*n+k];\n          }\n        }\n        break; // break out of iteration loop and move on to next k value\n      }\n      if (iteration >= itmax-1) {\n        throw new Error('SVD: No convergence');\n      }\n      // shift from bottom 2x2 minor\n      x = q[l];\n      y = q[k-1];\n      g = e[k-1];\n      h = e[k];\n      f = ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);\n      g = pythag(f, 1.0);\n      if (f < 0) {\n        f = ((x-z)*(x+z)+h*(y/(f-g)-h))/x;\n      } else {\n        f = ((x-z)*(x+z)+h*(y/(f+g)-h))/x;\n      }\n      // next QR transformation\n      c = 1.0;\n      s = 1.0;\n      for (i = l+1; i < k+1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s*g;\n        g = c*g;\n        z = pythag(f,h);\n        e[i-1] = z;\n        c = f/z;\n        s = h/z;\n        f = x*c+g*s;\n        g = -x*s+g*c;\n        h = y*s;\n        y = y*c;\n        for (j = 0; j < n; j++) {\n          x = v.data[j*n+i-1];\n          z = v.data[j*n+i];\n          v.data[j*n+i-1] = x*c+z*s;\n          v.data[j*n+i] = -x*s+z*c;\n        }\n        z = pythag(f, h);\n        q[i-1] = z;\n        c = f/z;\n        s = h/z;\n        f = c*g+s*y;\n        x = -s*g+c*y;\n        for (j = 0; j < m; j++) {\n          y = u.data[j*n+i-1];\n          z = u.data[j*n+i];\n          u.data[j*n+i-1] = y*c+z*s;\n          u.data[j*n+i] = -y*s+z*c;\n        }\n      }\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x;\n      // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/svd-golub-reinsch.js\n// module id = 5\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/svd-golub-reinsch.js?")},/*!********************************!*\
  !*** ./engine/matrix/lstsq.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst Matrix  = __webpack_require__(/*! ./matrix */ 4);\nconst svd     = __webpack_require__(/*! ./svd-golub-reinsch */ 5);\nconst dist    = __webpack_require__(/*! ./distributions-socr */ 7);\n\n/**\n * Computes total least squares regression on the matrix `A`, already decomposed\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\n *\n * @param {Matrix<m,n>} A Data matrix\n * @param {Matrix<m,m>} U U matrix resulting from SVD\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\n * @param {Matrix<n,n>} V V matrix resulting from SVD\n * @param {Matrix<m,1>} b Independent column\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\n */\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S\n    , m = A.shape[0]\n    , n = A.shape[1]\n    , eps = Number.EPSILON\n    , efcols = []\n    , maxEig = Math.max.apply(null, s.data)\n    , i, d, x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n)*eps*maxEig) {\n      s.data[i] = 0;\n    }\n  }\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n  x = V.dot(d);\n  return x;\n}\n\n/**\n * Compute least squares regression using normal equations, then compute\n * analytical statistics to determine the quality of the fit for the model and\n * for each term in the model.\n *\n *    B'      = inv(X'X)X'y                       <-- weight vector\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSR / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i = B' / sqrt( inv(X'X)[i,i] * MSE )      / is element-wise\n *\n * @return {object} Regression results\n */\nfunction lstsqNEWithStats(X, y) {\n  var XT            = X.T\n    , pseudoInverse = XT.dot(X).inv()\n    , BHat          = pseudoInverse.dot(XT).dot(y)\n    , yHat          = X.dot(BHat)\n\n  // fit statistics\n    , nd            = X.shape[0]\n    , np            = X.shape[1]\n    , sse           = y.sub(yHat).dotPow(2).sum()\n    , tss           = y.sub(y.sum() / y.shape[0]).dotPow(2).sum()\n    , ssr           = tss - sse\n    , vary          = tss / (nd - 1)\n    , msr           = ssr / (np - 1)\n    , mse           = sse / (nd - np)\n    , rsq           = 1 - (sse / tss)\n    , crsq          = 1 - rsq\n    , adjrsq        = 1 - (mse / vary)\n    , f             = msr / mse\n    , aic           = Math.log10(mse) + 2*(np / nd)\n    , bic           = Math.log10(mse) + np*(Math.log10(nd) / nd)\n\n  // for t-statistics\n    , rtmse         = Math.sqrt(mse)\n    , sec           = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse)\n    , tstats        = BHat.dotDivide(sec)\n    , pts           = tstats.clone();\n\n  pts.data.set(pts.data.map((t) => dist.pt(t, nd - np)));\n\n  return {\n    weights : BHat,\n    tstats  : tstats,\n    mse     : mse,\n    rsq     : rsq,\n    crsq    : crsq,\n    adjrsq  : adjrsq,\n    f       : f,\n    pf      : dist.pf(f, np, nd - np),\n    aic     : aic,\n    bic     : bic,\n    pts     : pts\n  };\n}\n\n/**\n * Compute least squares regression using singular value decomposition, then\n * compute analytical statistics to determine the quality of the fit for the\n * model and for each term in the model.\n *\n *    U, s, V = svd(X)\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSM / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i     = it's complicated...see code\n *\n * @return {object} Regression results\n */\nfunction lstsqSVDWithStats(X, y) {\n  var decomposition = svd(X)\n    , U             = decomposition[0]\n    , w             = Matrix.from(decomposition[1])\n    , V             = decomposition[2]\n    , BHat          = lstsqSVD(X, U, w, V, y)\n    , yHat          = X.dot(BHat)\n\n  // fit statistics\n    , nd            = X.shape[0]\n    , np            = X.shape[1]\n    , sse           = y.sub(yHat).dotPow(2).sum()\n    , tss           = y.sub(y.sum() / y.shape[0]).dotPow(2).sum()\n    , ssr           = tss - sse\n    , vary          = tss / (nd - 1)\n    , msr           = ssr / (np - 1)\n    , mse           = sse / (nd - np)\n    , rsq           = 1 - (sse / tss)\n    , crsq          = 1 - rsq\n    , adjrsq        = 1 - (mse / vary)\n    , f             = msr / mse\n    , aic           = Math.log10(mse) + 2*(np / nd)\n    , bic           = Math.log10(mse) + np*(Math.log10(nd) / nd)\n\n  // used for t-stat calculations\n    , VdivwSq       = V.dotDivide(w).dotPow(2)\n    , i;\n\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  var sec = new Matrix(1, X.shape[1])\n    , stdModelErr;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * mse);\n    sec.data[i] = stdModelErr;\n  }\n\n  var tstats        = BHat.dotDivide(sec);\n  var pts           = tstats.clone();\n\n  pts.data.set(pts.data.map((t) => dist.pt(t, nd - np)));\n\n  return {\n    weights : BHat,\n    tstats  : tstats,\n    mse     : mse,\n    rsq     : rsq,\n    crsq    : crsq,\n    adjrsq  : adjrsq,\n    f       : f,\n    pf      : dist.pf(f, np, nd - np),\n    aic     : aic,\n    bic     : bic,\n    pts     : pts\n  };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE  = lstsqNEWithStats;\n\nvar a = Matrix.from([[41.9, 29.1],\n                     [43.4, 29.3],\n                     [43.9, 29.5],\n                     [44.5, 29.7],\n                     [47.3, 29.9],\n                     [47.5, 30.3],\n                     [47.9, 30.5],\n                     [50.2, 30.7],\n                     [52.8, 30.8],\n                     [53.2, 30.9],\n                     [56.7, 31.5],\n                     [57.0, 31.7],\n                     [63.5, 31.9],\n                     [65.3, 32.0],\n                     [71.1, 32.1],\n                     [77.0, 32.5],\n                     [77.8, 32.9]]);\nvar b = new Matrix(17, 1, [251.3, 251.3, 248.3, 267.5,\n                           273.0, 276.5, 270.3, 274.9,\n                           285.0, 290.0, 297.0, 302.5,\n                           304.5, 309.3, 321.7, 330.7,\n                           349.0]);\n\n\nvar a = new Matrix([[22,10, 2,  3, 7],\n                    [14, 7,10,  0, 8],\n                    [-1,13,-1,-11, 3],\n                    [-3,-2,13, -2, 4],\n                    [ 9, 8, 1, -2, 4],\n                    [ 9, 1,-7,  5,-1],\n                    [ 2,-6, 6,  5, 1],\n                    [ 4, 5, 0, -2, 2]]);\nvar b = new Matrix(8, 1, [12, 5, -2, -7, 1, 3, 10, 3]);\n\n// taylorfit's Bhat\n//var tfguess = Matrix.from([1.79903, 6.11149]).T;\nvar tfguess = Matrix.from([0.308165, 0.0720651, -0.0893553, 0.602561, 0.210042]).T;\n\n// rms test\nvar rms = [];\nvar ndf = a.shape[0] - 2;\nfor (var i = 0; i < a.shape[1]; i += 1) {\n  rms.push(a.col(i).abs().sum() / ndf);\n}\n\n/*\nrms = Matrix.from(rms);\nvar anorm = a.dotDivide(rms);\nvar bnorm = b.dotDivide(b.abs().sum() / ndf);\n\nconsole.log('rms', rms);\nvar estNE = lstsqNEWithStats(a, b);\nvar estSVD = lstsqSVDWithStats(a, b);\n\nconsole.log('ne  B:', estNE.weights.T);\nconsole.log('svd B:', estSVD.weights.T);\n\nconsole.log('ne  T:', estNE.tstats.T);\nconsole.log('svd T:', estSVD.tstats.T);\nconsole.log('realB:', tfguess.T);\n\nconsole.log(Math.sqrt(a.dot(estSVD.weights).dotMultiply(-1).add(b).dotPow(2).sum()));\nconsole.log(Math.sqrt(a.dot(tfguess).dotMultiply(-1).add(b).dotPow(2).sum()));\nconsole.log();\n\nconsole.log('       [ actual   , my guess , taylorfit ]');\nconsole.log('       -----------------------------------');\nconsole.log(b.hstack(a.dot(estSVD.weights)).hstack(a.dot(tfguess)));\n */\n\n\n/*\nconsole.log('NE  MSE:', estNE.mse);\nconsole.log('SVD MSE:', estSVD.mse);\nconsole.log();\nconsole.log('NE  Ts:');\nconsole.log(estNE.tstats.toString());\nconsole.log('SVD Ts:');\nconsole.log(estSVD.tstats.toString());\nconsole.log('NE  B:');\nconsole.log(estNE.weights.toString());\nconsole.log('SVD B:');\nconsole.log(estSVD.weights.toString());\n*/\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/lstsq.js\n// module id = 6\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/lstsq.js?")},/*!*********************************************!*\
  !*** ./engine/matrix/distributions-socr.js ***!
  \*********************************************/
function(module,exports){eval("'use strict';\n\n\nfunction statcom(q, i, j, b) {\n  var zz = 1\n    , z = zz\n    , k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k-b);\n    z += zz;\n    k += 2;\n  }\n  return z;\n}\n\n\n/**\n * Two sided T-distribution estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} t T-statistic for some independent variable\n * @param {Number} n Degrees of freedom\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\n */\nfunction pt(t, n) {\n  t = Math.abs(t);\n\n  var w = t / Math.sqrt(n)\n    , th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th)\n    , cth = Math.cos(th);\n\n  if ((n % 2) === 1) {\n    return 1 - (th + sth * cth * statcom(cth*cth, 2, n-3, -1)) / (Math.PI / 2);\n  }\n  return 1 - sth * statcom(cth*cth, 1, n-3, -1);\n}\n\n\n/**\n * Fisher's F-density estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} f  F value for the model\n * @param {Number} n1 # of terms in the model\n * @param {Number} n2 Degrees of freedom\n * @return {Number} Probability of (F < f)\n */\nfunction pf(f, n1, n2) {\n  var x = n2/(n1*f+n2);\n\n  if ((n1 % 2) === 0) {\n    return statcom(1-x, n2, n1+n2-4, n2-2) * Math.pow(x, n2/2);\n  }\n  if ((n2 % 2) === 0) {\n    return 1 - statcom(x, n1, n1+n2-4, n1-2) * Math.pow(1-x, n1/2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1*f/n2))\n    , a = th / (Math.PI / 2)\n    , sth = Math.sin(th)\n    , cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth*cth, 2, n2-3, -1) / (Math.PI / 2);\n  }\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth*sth, n2+1, n1+n2-4, n2-2)\n            * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2-1)/2) {\n    c *= k/(k-0.5);\n    k += 1;\n  }\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/distributions-socr.js\n// module id = 7\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/distributions-socr.js?")},/*!*******************************!*\
  !*** ./engine/model/model.js ***!
  \*******************************/
function(module,exports,__webpack_require__){eval("\nconst lstsq         = __webpack_require__(/*! ../matrix */ 3).lstsq;\nconst Matrix        = __webpack_require__(/*! ../matrix */ 3).Matrix;\nconst utils         = __webpack_require__(/*! ../utils */ 2);\n\nconst Term          = __webpack_require__(/*! ./term */ 9);\nconst combos        = __webpack_require__(/*! ./combos */ 10);\n\n/**\n * Private members\n *\n * @private\n */\nconst _weights      = Symbol('weights');\nconst _Xaugmented   = Symbol('Xaugmented');\nconst _terms        = Symbol('terms');\nconst _exponents    = Symbol('exponents');\nconst _multipliers  = Symbol('multipliers');\nconst _headers      = Symbol('headers');\nconst _X            = Symbol('X');\nconst _y            = Symbol('y');\nconst _candyTerms   = Symbol('candidateTerms');\nconst _means        = Symbol('means');\nconst _variances    = Symbol('variances');\n\n\nfunction standardize(X) {\n  var stand = X.clone()\n    , n = stand.shape[0]\n    , m = stand.shape[1]\n    , vars = [], means = []\n    , i, j, mean, variance;\n\n  for (i = 0; i < m; i += 1) {\n    for (mean = 0, j = 0; j < n; j += 1) {\n      mean += stand.data[j * m + i];\n    }\n    mean /= n;\n    for (variance = 0, j = 0; j < n; j += 1) {\n      variance += Math.pow(stand.data[j * m + i] - mean, 2);\n    }\n    variance /= n;\n    for (j = 0; j < n; j += 1) {\n      stand.data[j * m + i] = (stand.data[j * m + i] - mean) / variance;\n    }\n    vars.push(variance);\n    means.push(mean);\n  }\n\n  return {\n    X: stand,\n    means: means,\n    vars: vars\n  };\n}\n\n\n/**\n * Representation of a predictive model using multivariate polynomial\n * regression.\n *\n * The model uses least-squares regression on a set of polynomial terms to\n * approximate data. The model is bounded by a set of exponents and set of # of\n * multiplicands, which limits the number of candidate terms for the model.\n *\n * NOTE: Each time a term is added or removed from the initially nil model, all\n * candidate terms need to be re-evaluated. For this reason, efficiency is a\n * primary concern here.\n *\n * @class Model\n */\nclass Model {\n\n  /**\n   * Craft a new model from an input feature matrix X, an actual value\n   * column y, a list of exponents, and a list of # of multiplicands.\n   *\n   * @constructor\n   * @param {Matrix<n,m>} X           The input feature set, where each column\n   *                                  is a feature and each row is an\n   *                                  observation\n   * @param {Matrix<n,1>} y           The true values for each observation\n   * @param {number[]}    exponents   List of exponents that a column can be\n   *                                  raised to\n   * @param {number}      multipliers Max number of multiplicands for each term,\n   *                                  for instance 1 means only the individual\n   *                                  columns can be terms (x, y, x^2, y^2, ..),\n   *                                  but 3 means that candidate terms with\n   *                                  1, 2, and 3 multiplicands will be computed\n   *                                  (x, xy, xyz, ...)\n   */\n  constructor(X, y, exponents=[1], multipliers=1, terms=[], headers=null) {\n    //var standardizedX = standardize(X);\n    this[_X] = X; //standardizedX.X;\n    //this[_means] = standardizedX.means;\n    //this[_variances] = standardizedX.vars;\n    this[_y] = y;\n    this[_headers] = headers;\n\n    this[_Xaugmented] = new Matrix(X.shape[0], 0);\n    this[_weights] = [];\n\n    // Create a range [1, 2, 3, ..., n] for n multipliers\n    multipliers = utils.range(1, multipliers + 1);\n\n    // Generate candidate terms for the given parameters\n    this[_candyTerms] = combos\n      .generateTerms(X.shape[1], exponents, multipliers)\n      .map((term) => new Term(term, this));\n\n    // Find the initial terms in candyTerms and add them to the model\n    this[_terms] = terms.map(\n      (pair) => this[_candyTerms].find((term) => term.equals(pair))\n    );\n\n    // Add bias term\n    this[_terms].push(new Term([[0, 0]], this));\n\n    // If any terms are specified, compute the model & all candidate terms\n    if (terms.length !== 0) {\n      this.compute();\n    }\n  }\n\n  /**\n   * Adds a term to the model. A term should either be a Term object, or a list\n   * of [column_index, exponent] pairs.\n   *\n   * Beware: Each time a term is added, every candidate term needs to be\n   * recomputed.\n   *\n   * @param {Term | [number, number][]} term The term to be added to the model\n   * @param {boolean} [recompute] Optional flag indicating whether or not to\n   *                              recompute the model\n   * @return {Term[]} List of current terms in the model\n   */\n  addTerm(term, recompute=true) {\n    if (!Array.isArray(term)) {\n      throw new TypeError('Expected an array of [col, exp] pairs');\n    }\n\n    term.forEach((pair) => {\n      if (!Array.isArray(pair) || pair.length !== 2) {\n        throw new TypeError('Invalid [col, exp] pair: ' + JSON.stringify(pair));\n      }\n    });\n\n    var found = this[_terms].find((existingTerm) => existingTerm.equals(term));\n\n    if (found) {\n      return this[_terms];\n    }\n\n    found = this[_candyTerms].find((candyTerm) => candyTerm.equals(term));\n\n    this[_terms].push(found);\n\n    if (recompute) {\n      this.compute();\n    }\n    return this[_terms];\n  }\n\n  /**\n   * Removes a term from the model. A term should either be a Term object, or a\n   * list of [column_index, exponent] pairs.\n   *\n   * Beware: Each time a term is removed, every candidate term needs to be\n   * recomputed.\n   *\n   * @param {Term | [number, number][]} term The term to be added to the model\n   * @param {boolean} [recompute] Optional flag indicating whether or not to\n   *                              recompute the model\n   * @return {Term[]} List of current terms in the model\n   */\n  removeTerm(termToRemove, recompute=true) {\n    this[_terms] = this[_terms].filter((term) => !term.equals(termToRemove));\n\n    if (recompute) {\n      this.compute();\n    }\n    return this[_terms];\n  }\n\n  /**\n   * Computes least squares regression and analytical statistics on the model as\n   * well as all of the candidate terms. This might take a little while,\n   * depending on how big the data are.\n   *\n   * @return {TODO: something per data contract} Regression and analytical\n   *    results\n   */\n  compute() {\n    this[_Xaugmented] = this[_terms]\n      .map((term) => term.col)\n      .reduce((prev, curr) => prev.hstack(curr),\n              new Matrix(this[_X].shape[0], 0));\n\n    // Perform least squares using the terms added the model\n    var things = lstsq(this[_Xaugmented], this[_y]);\n    this[_weights] = things.weights;\n\n    // Perform least squares with each term not in the model independently\n    var candidateTerms = this[_candyTerms]\n          // Filter out candidates already in the model\n          .filter((term) => !this[_terms].includes(term))\n          // Create primitive representation for each term\n          .map((term) => ({\n            term : term.term,\n            stats: term.getStats()\n          }));\n\n    return {\n      model: {\n        terms: this[_terms].map((term, i) => ({\n          term: term.term,\n          stats: {\n            t: things.tstats.data[i],\n            pt: things.pts.data[i]\n          },\n          coeff: things.weights.data[i]\n        })),\n        stats: things\n      },\n      candidates: candidateTerms\n    };\n  }\n\n  /**\n   * Make a prediction based on the values for each feature given in `testData`.\n   *\n   * @param {Matrix<k,m>} testData A set of observations for each feature (a\n   *                               matrix with the same # of columns as\n   *                               `this[_X]`, but as many rows as your heart\n   *                               desires)\n   * @return {Matrix<k,1>} Predictions\n   */\n  predict(testData) {\n    testData = Matrix.from(testData);\n    testData = this[_terms]\n      .map((term) => term.computeColumn(testData))\n      .reduce((prev, curr) => prev.hstack(curr),\n              new Matrix(testData.shape[0], 0));\n    return testData.dot(Matrix.from(this[_weights]).T);\n  }\n\n  /**\n   * The input feature matrix.\n   *\n   * @property {Matrix} X\n   */\n  get X() {\n    return this[_X];\n  }\n\n  /**\n   * The given training values.\n   *\n   * @property {Matrix} y\n   */\n  get y() {\n    return this[_y];\n  }\n\n  /**\n   * Current matrix, whose columns reflect the terms in the model.\n   *\n   * @property {Matrix} data\n   */\n  get data() {\n    return this[_Xaugmented];\n  }\n\n  /**\n   * Coefficients derived by least squares regression.\n   *\n   * @property {Matrix} weights\n   */\n  get weights() {\n    return this[_weights];\n  }\n\n  /**\n   * Terms currently in the model.\n   *\n   * @property {Term[]} terms\n   */\n  get terms() {\n    return this[_terms];\n  }\n\n  /**\n   * Candidate terms (this also includes terms in the model already)\n   *\n   * @property {Term[]} candidates\n   */\n  get candidates () {\n    return this[_candyTerms];\n  }\n\n  /**\n   * Serializes the model for later use.\n   *\n   * @return {TODO: something per data contract}\n   */\n  toJSON() {\n    return {\n      headers     : this[_headers],\n      weights     : this[_weights].toArray(),\n      terms       : this[_terms]\n    };\n  }\n\n}\n\nmodule.exports = Model;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/model.js\n// module id = 8\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/model.js?")},/*!******************************!*\
  !*** ./engine/model/term.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("\nconst lstsq   = __webpack_require__(/*! ../matrix */ 3).lstsq;\nconst Matrix  = __webpack_require__(/*! ../matrix */ 3).Matrix;\n\nconst combos  = __webpack_require__(/*! ./combos */ 10);\n\n\n/**\n * Private members\n *\n * @private\n */\nconst _term   = Symbol('term');\nconst _model  = Symbol('model');\nconst _col    = Symbol('col');\n\n\nconst DEBUG   = false;\n\n\n/**\n * Term is a combination of input columns and exponents, such as x^2*y^3.\n *\n * @class Term\n */\nclass Term {\n\n  /**\n   * Creates a new Term.\n   *\n   * @constructor\n   * @param {[number, number][]}  term  List of pairs of numbers. The first is\n   *                                    the index of a column, where the second\n   *                                    is the exponent to raise that column to\n   * @param {Model}               model Model that owns this Term\n   */\n  constructor(term, model) {\n    this[_term] = term;\n    this[_model] = model;\n    this[_col] = this.computeColumn(model.X);\n  }\n\n  /**\n   * Computes least squares regression and analysis statistics on the parent\n   * model PLUS this term.\n   *\n   * @return {t: number, mse: number} Statistics for the regression\n   */\n  getStats() {\n    if (DEBUG) {\n      console.time('createPolyMatrix');\n    }\n    var XAugmented = this[_model].data.hstack(this[_col])\n      , theStats;\n\n    if (DEBUG) {\n      console.timeEnd('createPolyMatrix');\n    }\n\n    try {\n      if (DEBUG) {\n        console.time('lstsq');\n      }\n      theStats = lstsq(XAugmented, this[_model].y);\n      if (DEBUG) {\n        console.timeEnd('lstsq');\n      }\n      theStats.coeff = theStats.weights.get(0, theStats.weights.shape[0]-1);\n      theStats.t = theStats.tstats.get(0, theStats.tstats.shape[0]-1);\n      theStats.pt = theStats.pts.get(0, theStats.pts.shape[0]-1);\n      delete theStats.weights;\n      delete theStats.tstats;\n      delete theStats.pts;\n\n      return theStats;\n\n      // XXX: Obsolete\n      return {\n        coeff : theStats.weights.get(0, theStats.weights.shape[0]-1),\n        t     : theStats.tstats.data[[theStats.tstats.shape[0] - 1]],\n        mse   : theStats.mse\n      };\n    } catch (e) {\n      console.log(e);\n      return NaN;\n    }\n  }\n\n  /**\n   * Compute the data column for a given matrix.\n   *\n   * @param {Matrix} X The input data matrix\n   * @return {Matrix<n,1>} n x 1 Matrix -- polynomial combo of columns in term\n   */\n  computeColumn(X) {\n    var sum = new Matrix(X.shape[0], 1)\n    , i;\n\n    for (i = 0; i < this[_term].length; i += 1) {\n      sum = sum.add(X.col(this[_term][i][0]).dotPow(this[_term][i][1]));\n    }\n    return sum;\n  }\n\n  /**\n   * Determines if this term is equivalent to `other`.\n   *\n   * @param {Term | [number, number][]} other Term to compare against\n   * @return {boolean} True if the terms are equivalent, false otherwise\n   */\n  equals(other) {\n    other = other[_term] || other;\n\n    if (other.length !== this[_term].length) {\n      return false;\n    }\n\n    return other.every((oMult) => this[_term].find(\n      (tMult) => oMult[0] === tMult[0] && oMult[1] === tMult[1]\n    ));\n  }\n\n  /**\n   * Returns the list of pairs constituting the term.\n   *\n   * @property {[number, number][]} term\n   */\n  get term() {\n    return this[_term];\n  }\n\n  /**\n   * Returns the data column for this term.\n   *\n   * @property {Matrix<n,1>} col\n   */\n  get col() {\n    return this[_col];\n  }\n\n\n  /**\n   * Give a representation of the term in a pretty format.\n   *\n   * @return {string} Representation of this term\n   */\n  inspect(depth, options) {\n    return 'Term < ' + this[_term]\n        .map((t) => String.fromCharCode(t[0] + 97) + '^' + t[1])\n        .join(' + ') + ' >';\n  }\n\n}\n\nmodule.exports = Term;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/term.js\n// module id = 9\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/term.js?")},/*!********************************!*\
  !*** ./engine/model/combos.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst utils = __webpack_require__(/*! ../utils */ 2);\n\n/**\n * Generate all combinations of k terms.\n *\n * @param {*[]}     terms         Array of items to combine\n * @param {number}  k             # of items in every combination\n * @param {boolean} [replacement] If true, an item from `terms` can be repeated\n *                                in a single combination\n */\nlet combinations = function(terms, k, replacement) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n  if (k === 1) {\n    return terms.map((term) => [term]);\n  }\n\n  for (i = 0; i < terms.length; i += 1) {\n    var subCombos = combinations(\n      // with replacements    => slice at i (include the current term)\n      // without replacements => slice at i + 1 (exclude current term)\n      terms.slice(i + !replacement),\n      k - 1,\n      replacement\n    );\n    // prepend the current term to each sub combo\n    combos = combos.concat(subCombos.map((combo) => [terms[i]].concat(combo)));\n  }\n  return combos;\n};\n\n/**\n * Generates all combinations of k items using one item from each bin in `bins`.\n *\n *    bins = [[0, 1], [2, 3]], k = 2\n *  ->[[0, 2], [0, 3], [1, 2], [1, 3]]\n *\n *\n * @param {*[][]} bins  An array of arrays containing items. For each\n *                      combination, only one item from each bin can be present\n * @return {*[][]} Combos\n */\nlet combinationsFromBins = function(bins, k) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n  if (bins.length <= 0) {\n    return combos;\n  }\n  if (k === 1) {\n    return [].concat.apply([], bins).map((term) => [term]);\n  }\n  for (i = 0; i < bins[0].length; i += 1) {\n    var subCombos = combinationsFromBins(bins.slice(1), k - 1);\n    combos = combos.concat(subCombos.map((combo) => [bins[0][i]].concat(combo)));\n  }\n  return combos.concat(combinationsFromBins(bins.slice(1), k));\n};\n\n/**\n * Generates all possible combinations of exponentiated terms given a list of\n * exponents and a list of # of multiplicands\n *\n * @param {number}    features    Number of features in the original dataset\n * @param {number[]}  exponents   Array of exponents ([1, 2] means x, x^2)\n * @param {number[]}  multipliers Array of # of multiplicands ([1] means only\n *                                one multiplicand per term)\n * @return {[number, number][][]} List of terms\n */\nlet generateTerms = function(features, exponents, multipliers) {\n  var bins = utils\n        .range(0, features)\n        .map((index) => exponents.map((e) => [index, e]))\n\n    , combosForMults = multipliers.map((m) => combinationsFromBins(bins, m));\n\n  return [].concat.apply([], combosForMults);\n};\n\nmodule.exports.generateTerms = generateTerms;\nmodule.exports.combinations = combinations;\nmodule.exports.combinationsFromBins = combinationsFromBins;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/combos.js\n// module id = 10\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/combos.js?")}]);