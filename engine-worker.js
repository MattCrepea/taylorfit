!function(){this.global=this,this.window=this}(),function(n){function t(a){if(e[a])return e[a].exports;var s=e[a]={exports:{},id:a,loaded:!1};return n[a].call(s.exports,s,s.exports,t),s.loaded=!0,s.exports}var e={};return t.m=n,t.c=e,t.p="",t(0)}([/*!********************************!*\
  !*** ./engine/worker/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("/*global onmessage, postMessage*/\n'use strict';\n\nconst Model = __webpack_require__(/*! ../model/model2 */ 1);\nconst m     = new Model();\n\nvar log = function () {\n  console.debug('[Engine]:', ...arguments);\n};\n\nm.on('getCandidates.start', () => postMessage({\n  type: 'progress.start',\n  data: {}\n}));\n\nm.on('getCandidates.start', () => console.time('getCandidates'));\nm.on('getCandidates.end', () => console.timeEnd('getCandidates'));\n\nlet getCandidateProgressInterval = 100;\nlet onGetCandidateId = m.on('getCandidates.each', (data) => {\n  if (data.curr % getCandidateProgressInterval === 0) {\n    postMessage({\n      type: 'progress',\n      data: { curr: data.curr, total: data.total }\n    });\n  }\n});\n\nm.on('getCandidates.end', () => postMessage({\n  type: 'progress.end',\n  data: {}\n}));\n\nonmessage = function (e) {\n  var type = e.data.type\n    , data = e.data.data;\n\n  log(e.data);\n\n  switch(type) {\n\n  case 'update':\n    if (data.dataset != null) {\n      m.setData(data.dataset);\n    }\n    if (data.exponents != null) {\n      m.setExponents(data.exponents);\n    }\n    if (data.multiplicands != null) {\n      m.setMultiplicands(data.multiplicands);\n    }\n    if (data.dependent != null) {\n      m.setDependent(data.dependent);\n    }\n    if (data.lags != null) {\n      m.setLags(data.lags);\n    }\n\n    postMessage({\n      type: 'candidates',\n      data: m.getCandidates()\n    });\n    postMessage({\n      type: 'model',\n      data: m.getModel()\n    });\n    break;\n\n  case 'get_terms':\n    postMessage({\n      type: 'candidates',\n      data: m.getCandidates()\n    });\n    break;\n\n  case 'add_term':\n    m.addTerm(data);\n\n    postMessage({\n      type: 'candidates',\n      data: m.getCandidates()\n    });\n    postMessage({\n      type: 'model',\n      data: m.getModel()\n    });\n    break;\n\n  case 'remove_term':\n    m.removeTerm(data);\n\n    postMessage({\n      type: 'candidates',\n      data: m.getCandidates()\n    });\n    postMessage({\n      type: 'model',\n      data: m.getModel()\n    });\n    break;\n\n  default:\n    postMessage({ type: 'error', data: 'Invalid type: ' + type });\n\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/worker/index.js\n// module id = 0\n// module chunks = 0\n//# sourceURL=webpack:///./engine/worker/index.js?")},/*!********************************!*\
  !*** ./engine/model/model2.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("\n\nconst Matrix          = __webpack_require__(/*! ../matrix */ 2).Matrix;\nconst lstsq           = __webpack_require__(/*! ../matrix */ 2).lstsq;\n\nconst utils           = __webpack_require__(/*! ../utils */ 4);\nconst Observable      = __webpack_require__(/*! ../observable */ 8);\n\nconst TermPool        = __webpack_require__(/*! ./termpool */ 10);\nconst combos          = __webpack_require__(/*! ./combos */ 13);\n\nconst _data           = Symbol('data');\nconst _exponents      = Symbol('exponents');\nconst _multiplicands  = Symbol('multiplicands');\nconst _lags           = Symbol('lags');\nconst _dependent      = Symbol('dependent');\nconst _subsets        = Symbol('subsets');\nconst _terms          = Symbol('terms');\nconst _cache          = Symbol('cache');\n\nconst INTERCEPT       = [[0, 0, 0]];\nconst DEFAULT_SUBSET  = 'fit';\n\nclass Model extends Observable {\n\n  constructor() {\n    super();\n\n    this[_data] = new Matrix(0, 0);\n    this[_exponents] = [1];\n    this[_multiplicands] = [1];\n    this[_lags] = [];\n    this[_dependent] = 0;\n    this[_subsets] = {};\n    this[_subsets][DEFAULT_SUBSET] = [];\n\n    this[_cache] = { X: {}, y: {}, data: {} };\n\n    this[_terms] = [];\n    this.termpool = new TermPool(this);\n  }\n\n  setData(data) {\n    if (!(data instanceof Matrix)) {\n      data = new Matrix(data);\n    }\n    this[_data] = data;\n    this[_subsets] = {};\n    this[_subsets][DEFAULT_SUBSET] = utils.range(0, data.shape[0]);\n\n    this[_terms] = [];\n    this[_cache].X = {};\n    this[_cache].y = {};\n    this[_cache].data = {};\n    this[_cache].highestLag = null;\n    this.fire('setData', data);\n    return this;\n  }\n\n  setExponents(exponents) {\n    this[_exponents] = exponents.slice();\n    this.fire('setExponents', exponents);\n    return this;\n  }\n\n  setMultiplicands(multiplicands) {\n    this[_multiplicands] = utils.range(1, multiplicands + 1);\n    this.fire('setMultiplicands', multiplicands);\n    return this;\n  }\n\n  setDependent(dependent) {\n    this[_dependent] = dependent;\n    this[_terms] = [];\n    this[_cache].X = {};\n    this[_cache].y = {};\n    this[_cache].highestLag = null;\n    this.fire('setDependent', dependent);\n    return this;\n  }\n\n  setLags(lags) {\n    this[_lags] = lags.slice();\n    this.fire('setLags', lags);\n    return this;\n  }\n\n  subset(name, startRow, endRow) {\n    if (!Array.isArray(startRow)) {\n      startRow = utils.range(startRow, endRow || this[_data].shape[0]);\n    }\n    this.termpool.clearCache();\n    this[_cache].X = {};\n    this[_cache].y = {};\n    this[_cache].data = {};\n    this[_subsets][name] = startRow;\n    this.fire('subset', { name, startRow, endRow });\n    return this;\n  }\n\n  addTerm(term) {\n    let found = this[_terms].find((t) => t.equals(term));\n\n    if (!found) {\n      found = this.termpool.get(term);\n      this[_terms].push(found);\n      this[_cache].X = {};\n      this[_cache].y = {};\n      this[_cache].highestLag = null;\n    }\n    this.fire('addTerm', term);\n    return this;\n  }\n\n  removeTerm(term) {\n    this[_terms] = this[_terms].filter((t) => !t.equals(term));\n    this[_cache].X = {};\n    this[_cache].y = {};\n    this[_cache].highestLag = null;\n    this.fire('removeTerm', term);\n    return this;\n  }\n\n  getTerms() {\n    return this[_terms].slice();\n  }\n\n  getCandidates() {\n    this.fire('getCandidates.start');\n\n    let independentCols = utils.join([\n      utils.range(0, this[_dependent]),\n      utils.range(this[_dependent] + 1, this[_data].shape[1])\n    ]);\n\n    // Candidates from exp / mults / lag\n    let candidates = combos.generateTerms(\n      independentCols,\n      this[_exponents],\n      this[_multiplicands],\n      this[_lags]\n    ).map(this.termpool.get.bind(this.termpool));\n\n    // Intercept candidate (column of 1s)\n    candidates.unshift(this.termpool.get(INTERCEPT));\n\n    // Dependent column for each lag\n    [].push.apply(candidates, this[_lags].map(\n      (lag) => this.termpool.get([[this[_dependent], 1, lag]])));\n\n    // For each candidate, get the stats for it alongside terms in the model\n    let results = candidates\n      .filter((cand) => !this[_terms].includes(cand))\n      .map((candidate, i) => {\n        this.fire('getCandidates.each', { curr: i, total: candidates.length });\n\n        let stats = candidate.getStats();\n        return {\n          term: candidate.valueOf(),\n          coeff: stats.coeff,\n          stats\n        };\n      });\n\n    this.fire('getCandidates.end');\n    return results;\n  }\n\n  getModel(testSubset) {\n    let highestLag = this.highestLag()\n      , X = this.X().lo(highestLag)\n      , y = this.y().lo(highestLag);\n\n    let stats = lstsq(X, y);\n\n    if (testSubset) {\n      stats = lstsq(this.X(testSubset), this.y(testSubset), stats.weights);\n    }\n\n    let terms = this[_terms].map((term, i) => ({\n      term: term.valueOf(),\n      coeff: stats.weights.get(i, 0),\n      stats: {\n        t: stats.tstats.get(i, 0),\n        'p(t)': stats.pts.get(i, 0)\n      }\n    }));\n\n    // Fix display name for pf to p(f)\n    stats['p(f)'] = stats.pf;\n    delete stats.pf;\n\n    return { terms, stats };\n  }\n\n  highestLag() {\n    if (this[_cache].highestLag == null) {\n      this[_cache].highestLag = this[_terms].reduce(\n        (highest, term) => Math.max(highest, term.lag),\n        0);\n    }\n    return this[_cache].highestLag;\n  }\n\n  X(subset=DEFAULT_SUBSET) {\n    if (this[_cache].X[subset] == null) {\n      this[_cache].X[subset] = this[_terms]\n        .reduce((prev, curr) => prev.hstack(curr.col(subset)),\n                new Matrix(this[_subsets][subset].length, 0));\n    }\n\n    return this[_cache].X[subset];\n  }\n\n  y(subset=DEFAULT_SUBSET) {\n    if (this[_cache].y[subset] == null) {\n      this[_cache].y[subset] = this.data(subset).subset(':', this[_dependent]);\n    }\n    return this[_cache].y[subset];\n  }\n\n  data(subset=DEFAULT_SUBSET) {\n    if (!this[_cache].data[subset]) {\n      this[_cache].data = {};\n      for (let subset in this[_subsets]) {\n        this[_cache].data[subset] = this[_data].subset(this[_subsets][subset]);\n      }\n    }\n    return this[_cache].data[subset];\n  }\n\n}\n\nModel.prototype.DEFAULT_SUBSET = DEFAULT_SUBSET;\n\nmodule.exports = Model;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/model2.js\n// module id = 1\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/model2.js?")},/*!********************************!*\
  !*** ./engine/matrix/index.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("\n// lstsqSVD | lstsqNE\nconst METHOD = 'lstsqSVD';\n\nmodule.exports.Matrix = __webpack_require__(/*! ./matrix */ 3);\nmodule.exports.svd    = __webpack_require__(/*! ./svd-golub-reinsch */ 5);\nmodule.exports.lstsq  = __webpack_require__(/*! ./lstsq */ 6)[METHOD];\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/index.js\n// module id = 2\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/index.js?")},/*!*********************************!*\
  !*** ./engine/matrix/matrix.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("\nconst utils = __webpack_require__(/*! ../utils */ 4);\n\n/**\n * Private members\n *\n * @private\n */\nconst _data = Symbol('data');\nconst _m    = Symbol('m');\nconst _n    = Symbol('n');\n\n// Maximum number of decimal points to print\nconst PRINT_DECIMALS = 5;\n\n// Number.MAX_SAFE_INTEGER value [ i.e. doesn't support :( ]\nconst MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n/**\n * Swap rows `i` and `j` in matrix `m` in place.\n *\n * @param {Matrix} m\n * @param {number} i\n * @param {number} j\n */\nfunction swapRows(m, i, j) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    temp = m[_data][j * m[_n] + k];\n    m[_data][j * m[_n] + k] = m[_data][i * m[_n] + k];\n    m[_data][i * m[_n] + k] = temp;\n  }\n}\n\n/**\n * Divide row `i` in both matrix `m` and matrix `inv` by `factor`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction divideRow(m, inv, i, factor) {\n  var k, temp;\n\n  for (k = 0; k < m[_n]; k += 1) {\n    m[_data][i * m[_n] + k] /= factor;\n    inv[_data][i * m[_n] + k] /= factor;\n  }\n}\n\n/**\n * Subtract multiple of row `i` and column `j` from every row in `m` and `inv`.\n *\n * @param {Matrix} m\n * @param {Matrix} inv\n * @param {number} i\n * @param {number} j\n */\nfunction subtractRowMultiple(m, inv, i, j) {\n  var k, l, factor;\n\n  for (l = 0; l < m[_m]; l += 1) {\n    factor = m[_data][l * m[_n] + j];\n\n    if (l !== i) {\n      for (k = 0; k < m[_n]; k += 1) {\n        m[_data][l * m[_n] + k] -= m[_data][i * m[_n] + k] * factor;\n        inv[_data][l * m[_n] + k] -= inv[_data][i * m[_n] + k] * factor;\n      }\n    }\n  }\n}\n\n\n/**\n * A speedy 2-dimensional matrix implementation.\n *\n * @class Matrix\n */\nclass Matrix {\n\n  /**\n   * Creates a new Matrix of size <n, m>, using `stuff`.\n   *\n   * If `stuff` is a Float64Array, then the reference will be used. Otherwise,\n   * its contents will be copied into a new Float64Array.\n   *\n   * @param {number | number[][]}       n     Number of rows (or nested arrays\n   *                                          that look like a matrix)\n   * @param {number}                    m     Number of columns\n   * @param {Float64Array | number[][]} stuff Items to populate the matrix\n   */\n  constructor(m, n, stuff) {\n    if (m instanceof Matrix) {\n      return m;\n    }\n    if (Array.isArray(m)) {\n      return Matrix.from(m);\n    }\n    if (stuff != null) {\n      stuff = (stuff instanceof Float64Array)\n              ? stuff\n              : Float64Array.from(stuff);\n      if (stuff.length !== m * n) {\n        throw new Error('Array does not match the specified dimensions');\n      }\n    } else {\n      stuff = new Float64Array(m * n);\n    }\n    this[_data] = stuff;\n    this[_m] = m;\n    this[_n] = n;\n    return this;\n  }\n\n  /**\n   * Retrieve the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @return {number} Element at (i, j)\n   */\n  get(i, j) {\n    return this[_data][i * this[_n] + j];\n  }\n\n  /**\n   * Set the element at the ith row and jth column.\n   *\n   * @param {number} i s.t. 0 <= i < m\n   * @param {number} j s.t. 0 <= i < n\n   * @param {number} value To replace the existing one\n   * @return {number} Element at (i, j)\n   */\n  set(i, j, value) {\n    return this[_data][i * this[_n] + j] = value;\n  }\n\n  /**\n   * Performs element-wise addition between two matrices and returns a new copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this + other\n   * @throws {Error} If dimensions do not match\n   */\n  add(other) {\n    var sum = this.clone()\n      , i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape +\n                        ') and (' + other.shape + ') do not match: ' +\n                        this[_n] + ' !== ' + other[_m] + ' && ' +\n                        this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] += other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs element-wise subtraction between two matrices and returns a new\n   * copy.\n   *\n   * @param {number | Matrix<m,n>} other  Scalar or Matrix with equivalent\n   *                                      dimensions to this\n   * @return {Matrix<m,n>} this - other\n   * @throws {Error} If dimensions do not match\n   */\n  sub(other) {\n    var sum = this.clone()\n      , i;\n\n    if (typeof other === 'number') {\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other;\n      }\n    } else {\n      if (this[_m] !== other[_m] || this[_n] !== other[_n]) {\n        throw new Error('Dimensions (' + this.shape +\n                        ') and (' + other.shape + ') do not match: ' +\n                        this[_n] + ' !== ' + other[_m] + ' && ' +\n                        this[_m] + ' !== ' + other[_m]);\n      }\n\n      for (i = 0; i < sum[_data].length; i += 1) {\n        sum[_data][i] -= other[_data][i];\n      }\n    }\n    return sum;\n  }\n\n  /**\n   * Performs matrix multiplication between this and other.\n   *\n   * @param {Matrix<n,k>} other Matrix whose rows must be === to this's columns\n   * @return {Matrix<m,k>} this * other\n   * @throws {Error} If dimensions do not match\n   */\n  dot(other) {\n    if (this[_n] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape +\n                      ') and (' + other.shape + ') do not match: ' +\n                      this[_n] + ' !== ' + other[_m]);\n    }\n\n    var product = new Matrix(this[_m], other[_n])\n      , i, j, k, sum;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < other[_n]; j += 1) {\n        for (k = 0, sum = 0; k < this[_n]; k += 1) {\n          sum += this[_data][i * this[_n] + k] *\n                 other[_data][k * other[_n] + j];\n        }\n        product[_data][i * other[_n] + j] = sum;\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Computes the inverse of the matrix (only if it is square!).\n   *\n   * @return {Matrix<m,n>} Inverse matrix s.t. this * inv(this) === I\n   * @throws {Error} If not a square matrix\n   */\n  inv() {\n    if (this[_m] !== this[_n]) {\n      throw new Error('Must be square');\n    }\n\n    var self = this.clone()\n      , inverse = Matrix.eye(this[_m], this[_n])\n      , i, j, k, factor;\n\n    for (i = 0, j = 0; i < self[_m] && j < self[_n]; i += 1, j += 1) {\n      if (self[_data] === 0) {\n        for (\n          k = 0;\n          self[_data][k * self[_n] + j] !== 0 && k < self[_m];\n          k += 1\n        )\n          ;\n        if (k >= self[_m]) {\n          j += 1;\n          continue;\n        }\n        swapRows(self, j, k);\n        swapRows(inverse, j, k);\n      }\n      divideRow(self, inverse, j, self[_data][j * self[_n] + j]);\n      subtractRowMultiple(self, inverse, i, j);\n    }\n    return inverse;\n  }\n\n  /**\n   * Returns a copy of the matrix.\n   *\n   * @return {Matrix<m,n>} Fresh clone\n   */\n  clone() {\n    return new Matrix(this[_m], this[_n], this[_data].slice());\n  }\n\n  /**\n   * Horizontally stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<m,k>} other Matrix whose rows === this's rows\n   * @return {Matrix<m,n+k>} Horizontal concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  hstack(other) {\n    if (this[_m] !== other[_m]) {\n      throw new Error('Dimensions (' + this.shape +\n                      ') and (' + other.shape + ') do not match: ' +\n                      this[_m] + ' !== ' + other[_m]);\n    }\n\n    var newM = this[_n] + other[_n]\n      , stacked = new Matrix(this[_m], newM)\n      , i, j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        stacked[_data][i*newM + j] = this[_data][i*this[_n] + j];\n      }\n      for (j = 0; j < other[_n]; j += 1) {\n        stacked[_data][i*newM + this[_n]+j] = other[_data][i*other[_n] + j];\n      }\n    }\n    return stacked;\n  }\n\n  /**\n   * Vertically stacks `other` and returns the new matrix.\n   *\n   * @param {Matrix<k,n>} other Matrix whose cols === this's cols\n   * @return {Matrix<m+k,n>} Vertical concatenation of this and other\n   * @throws {Error} If dimensions do not match\n   */\n  vstack(other) {\n    if (this[_n] !== other[_n]) {\n      throw new Error('Dimensions (' + this.shape +\n                      ') and (' + other.shape + ') do not match: ' +\n                      this[_n] + ' !== ' + other[_n]);\n    }\n\n    var stacked = new Matrix(this[_m] + other[_m], this[_n]);\n\n    stacked[_data].subarray(0, this[_m] * this[_n]).set(this[_data]);\n    stacked[_data].subarray(this[_m] * this[_n]).set(other[_data]);\n    return stacked;\n  }\n\n  /**\n   * Performs element-wise exponentiation to the matrix and returns a new copy.\n   *\n   * @param {number} exponent Power to raise each element to\n   * @return {Matrix<m,n>} this[i,i]^exponent\n   */\n  dotPow(exponent) {\n    var powd = this.clone()\n      , i;\n\n    for (i = 0; i < powd[_data].length; i += 1) {\n      powd[_data][i] = Math.pow(powd[_data][i], exponent);\n      if (!Number.isFinite(powd[_data][i])) {\n        powd[_data][i] = MAX_SAFE_INTEGER;\n      }\n    }\n    return powd;\n  }\n\n  /**\n   * Performs element-wise multiplication to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Multiplicand to multiply each element by, or a\n   *                            matrix whose elements will be iterated through\n   *                            in alignment with this\n   * @return {Matrix<m,n>} this[i,i] * n   OR   this[i,i] * n[i,i]\n   */\n  dotMultiply(n) {\n    var product = this.clone()\n      , i;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] * n[_data][i];\n      }\n    }\n    return product;\n  }\n\n  /**\n   * Performs element-wise division to the matrix and returns a new copy.\n   *\n   * @param {number | Matrix} n Divisor to divide each element by, or a matrix\n   *                            whose elements will be iterated through in\n   *                            alignment with this\n   * @return {Matrix<m,n>} this[i,i] / n   OR   this[i,i] / n[i,i]\n   */\n  dotDivide(n) {\n    var product = this.clone()\n      , i, j;\n\n    if (typeof n === 'number') {\n      for (i = 0; i < product[_data].length; i += 1) {\n        product[_data][i] = product[_data][i] / n;\n      }\n    } else if (n instanceof Matrix) {\n      for (i = 0, j = 0; i < product[_data].length; i += 1, j += 1) {\n        if (j >= n[_data].length) {\n          j = 0;\n        }\n        product[_data][i] = product[_data][i] / n[_data][j];\n      }\n    }\n    return product;\n  }\n\n  /**\n   * @see inspect\n   */\n  toString() {\n    return this.inspect();\n  }\n\n  /**\n   * Stringifies the matrix into a pretty format\n   *\n   * @return {string} Representation of the matrix\n   */\n  inspect(depth, options={ stylize: (x) => ''+x }) {\n    var repr = options.stylize(this.constructor.name, 'none')\n      , strings = Array.from(this[_data])\n          .map((i) => (''+i).match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/))\n      , lwidth = Math.max.apply(null, strings.map((match) => match[1].length))\n      , rwidth = Math.min(\n          Math.max.apply(null, strings.map((match) => match[2].length)),\n          PRINT_DECIMALS\n        )\n      , rows = []\n      , i;\n\n    strings = Array.from(this[_data]).map(\n      (n) => options.stylize(utils.formatNum(lwidth, rwidth, n), 'number')\n    );\n\n    for (i = 0; i < this[_m]; i += 1) {\n      rows.push('[ ' + strings.slice(i*this[_n], (i+1)*this[_n]).join(', ') + ' ]');\n    }\n\n    return repr + ' ' + utils.padAll(\n      this.constructor.name.length + 1,\n      rows.join('\\n')\n    ).trim();\n  }\n\n  /**\n   * Retrieves/sets the ith column of the matrix\n   *\n   * @param {number}    i         Column index\n   * @param {number[]}  [newCol]  Elements to replace the col with\n   * @return {Matrix<m,1>} Column as a matrix\n   */\n  col(i, newCol) {\n    var theCol = new Matrix(this[_m], 1)\n      , k;\n\n    if (newCol != null) {\n      if (newCol.length > this[_m]) {\n        throw new RangeError('newCol cannot be longer than ' + this[_m]);\n      }\n      for (k = 0; k < this[_m]; k += 1) {\n        this[_data][k * this[_n] + i] = newCol[k];\n      }\n    }\n\n    for (k = 0; k < this[_m]; k += 1) {\n      theCol[_data][k] = this[_data][k * this[_n] + i];\n    }\n    return theCol;\n  }\n\n  /**\n   * Retrieves/sets the ith row of the matrix\n   *\n   * @param {number}    i         Row index\n   * @param {number[]}  [newRow]  Elements to replace the row with\n   * @return {Matrix<1,n>} Row as a matrix\n   */\n  row(i, newRow) {\n    if (newRow != null) {\n      if (newRow.length > this[_n]) {\n        throw new RangeError('newRow cannot be longer than ' + this[_n]);\n      }\n      this[_data].subarray(i * this[_n]).set(newRow);\n    }\n    return new Matrix(\n      1, this[_n],\n      this[_data].slice(i * this[_n], (i+1) * this[_n])\n    );\n  }\n\n  /**\n   * Retrieves a subset of the matrix, constructed from indices in `rows` and\n   * `cols`. The resulting matrix will have rows s.t. result[i] = this[rows[i]]\n   * and columns s.t. result[i][j] = this[rows[i][cols[j]]]\n   *\n   * @param {number[]} rows Array of indices used to construct the subset\n   * @param {number[]} cols Array of indices used to construct the subset\n   * @return {Matrix<rows.length, cols.length>} Subset of this\n   */\n  subset(rows=':', cols=':') {\n    rows = utils.convertRange(rows, this[_m]);\n    cols = utils.convertRange(cols, this[_n]);\n\n    var subMatrix = new Matrix(rows.length, cols.length)\n      , i, j;\n\n    for (i = 0; i < rows.length; i += 1) {\n      for (j = 0; j < cols.length; j += 1) {\n        subMatrix[_data][i * subMatrix[_n] + j] =\n          this[_data][rows[i] * this[_n] + cols[j]];\n      }\n    }\n    return subMatrix;\n  }\n\n  // TODO: document\n  lo(row=0) {\n    return new Matrix(\n      this[_m] - row,\n      this[_n],\n      this[_data].slice(row * this[_n])\n    );\n  }\n\n  // TODO: document\n  hi(row=0) {\n    return new Matrix(\n      row,\n      this[_n],\n      this[_data].slice(0, row * this[_n])\n    );\n  }\n\n  // TODO: document\n  shift(rows) {\n    let newData = new Float64Array(this[_m] * this[_n]);\n    newData.subarray(this[_n] * rows).set(\n      this[_data].subarray(0, -(this[_n] * rows) || this[_data].length));\n    return new Matrix(this[_n], this[_m], newData);\n  }\n\n  /**\n   * Retrieves the diagonal elements as a 1 x min(m, n) matrix.\n   *\n   * @return {Matrix<1,min(m,n)>} Diagonal elements\n   */\n  diag() {\n    var diagonal = new Matrix(1, Math.min(this[_m], this[_n]))\n      , i;\n\n    for (i = 0; i < this[_m] && i < this[_n]; i += 1) {\n      diagonal[_data][i] = this[_data][i * this[_n] + i];\n    }\n    return diagonal;\n  }\n\n  /**\n   * Performs `Math.abs()` on each element then returns the resulting matrix.\n   *\n   * @return {Matrix<m,n>} A clone of `this`, but with the absolute value of\n   *                       each element\n   */\n  abs() {\n    var absolute = this.clone()\n      , i;\n\n    for (i = 0; i < absolute[_data].length; i += 1) {\n      absolute[_data][i] = Math.abs(absolute[_data][i]);\n    }\n    return absolute;\n  }\n\n  /**\n   * Sums all of the elements.\n   *\n   * @return {number} Sum of all of the elements\n   */\n  sum() {\n    var tot = 0\n      , i;\n\n    for (i = 0; i < this[_data].length; i += 1) {\n      tot += this[_data][i];\n    }\n    return tot;\n  }\n\n  /**\n   * @property {Matrix<n,m>} T The transposition of the matrix\n   */\n  get T() {\n    var transpose = new Matrix(this[_n], this[_m])\n      , i, j;\n\n    for (i = 0; i < this[_m]; i += 1) {\n      for (j = 0; j < this[_n]; j += 1) {\n        transpose[_data][j * this[_m] + i] = this[_data][i * this[_n] + j];\n      }\n    }\n    return transpose;\n  }\n\n  /**\n   * @property {[number, number]} shape The shape of this matrix [m, n]\n   */\n  get shape() {\n    return [this[_m], this[_n]];\n  }\n\n  /**\n   * @property {Float64Array} data The underlying storage for the matrix\n   */\n  get data() {\n    return this[_data];\n  }\n\n  /**\n   * Generates a matrix full of random (0, 1) numbers.\n   *\n   * @static\n   * @return {Matrix<m,n>} Matrix full'a random numbas\n   */\n  static random(m, n) {\n    var randMatrix = new Matrix(m, n)\n      , i, j;\n\n    for (i = 0; i < m; i += 1) {\n      for (j = 0; j < n; j += 1) {\n        randMatrix[_data][i * n + j] = Math.random();\n      }\n    }\n    return randMatrix;\n  }\n\n  /**\n   * Generates a matrix whose diagonal elements equal 1.\n   *\n   * @static\n   * @return {Matrix<m,n>} Diagonal onez\n   */\n  static eye(m, n=m) {\n    var onez = new Matrix(m, n)\n      , i, j;\n\n    for (i = 0; i < m; i += 1) {\n      onez[_data][i * n + i] = 1;\n    }\n    return onez;\n  }\n\n  /**\n   * Creates a matrix from matrix-looking nested arrays, or a flat array and the\n   * given `m` and `n`.\n   *\n   * @param {iterable | Matrix} arr Values to populate the matrix with\n   * @param {number}            m   Rows in the new matrix\n   * @param {number}            n   Columns in the new matrix\n   */\n  static from(arr, m, n) {\n    if (arr instanceof Matrix) {\n      return arr.clone();\n    }\n    if (!Array.isArray(arr)) {\n      throw new TypeError('Expected an array or Matrix');\n    }\n    if (arr.length <= 0) {\n      return new Matrix(0, 0);\n    }\n\n    var i;\n\n    m = m || arr.length;\n    n = n || arr[0].length;\n\n    // handed a 1-d array\n    if (arr[0].length == null) {\n      return new Matrix(1, arr.length, Float64Array.from(arr));\n    }\n\n    // otherwise, it's a 2-d array (and hopefully not >2-d)\n    for (i = 0; i < arr.length; i += 1) {\n      if (arr[i].length !== n) {\n        throw new Error('All rows must have equal length');\n      }\n    }\n    return new Matrix(m, n, Float64Array.from(utils.join(arr)));\n  }\n\n  /**\n   * Creates a matrix using `arr` to fill the diagonal elements in order.\n   *\n   * @param {number[m]} arr Array of numbers\n   * @returns {Matrix<m,m>} Matrix consisting only of the diagonal elements\n   */\n  static diag(arr) {\n    var m = arr.length\n      , mat = new Matrix(m, m)\n      , i;\n\n    for (i = 0; i < m; i += 1) {\n      mat.data[i*m+i] = arr[i];\n    }\n    return mat;\n  }\n\n  static zeros(m, n=m) {\n    return this.eye(m, n).dotMultiply(0);\n  }\n\n}\n\nmodule.exports = Matrix;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/matrix.js\n// module id = 3\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/matrix.js?")},/*!*************************!*\
  !*** ./engine/utils.js ***!
  \*************************/
function(module,exports){eval("'use strict';\n\nfunction nspaces(n) {\n  n = Math.max(0, n);\n  return Array(n + 1).join(' ');\n}\n\nfunction pad(width, val) {\n  val = val || '';\n  return nspaces(width - (''+val).length) + val;\n}\n\n\nmodule.exports.range = (start, end) => {\n  if (start >= end) {\n    return [];\n  }\n  return Array(end - start).join(' ').split(' ').map((_, i) => i + start);\n};\n\nmodule.exports.convertRange = (str, length) => {\n  var range, start, end;\n\n  if (typeof str === 'number') {\n    return (str < 0) ? [length + str] : [str];\n  }\n  if (typeof str !== 'string') {\n    return str.map((ind) => (ind < 0) ? length + ind : ind);\n  }\n\n  if ((range = str.split(':')).length > 1) {\n    start = parseInt(range[0]) || 0;\n    end = parseInt(range[1]) || length;\n\n    if (start < 0) {\n      start = length + start;\n    }\n    if (end < 0) {\n      end = length + end;\n    }\n    return module.exports.range(start, end);\n  }\n\n  throw new TypeError('Invalid range');\n};\n\nmodule.exports.formatNum = (leftwidth, rightwidth, val) => {\n  val = ''+val;\n  var match = val.match(/(NaN|-?Infinity|-?\\d*)\\.?(\\d*)/)\n    , whole = match[1]\n    , frac = match[2]\n    , repr = '';\n\n  if (frac.length > rightwidth) {\n    frac = frac.slice(0, rightwidth);\n  }\n  repr += nspaces(leftwidth - whole.length) + whole;\n  if (frac !== '' || rightwidth > 0) {\n    repr += '.';\n    repr += frac.slice(0, rightwidth) + nspaces(rightwidth - frac.length);\n  } else {\n    repr += nspaces(rightwidth + 1);\n  }\n  return repr;\n};\n\nmodule.exports.padAll = (lwidth, str) => {\n  if (Array.isArray(str)) {\n    return str.map((s) => module.exports.padAll(lwidth + s.length, s));\n  } else if (typeof str === 'string') {\n    return str.split('\\n').map((s) => pad(lwidth + s.length, s)).join('\\n');\n  }\n  return pad(lwidth, str);\n};\n\nlet clone = module.exports.clone = (obj) => {\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n  if (Array.isArray(obj)) {\n    return obj.map(clone);\n  }\n\n  let newObj = {};\n  Object.keys(obj).forEach((key) => newObj[key] = clone(obj[key]));\n  return newObj;\n};\n\nmodule.exports.join = (arr) => [].concat.apply([], arr);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/utils.js\n// module id = 4\n// module chunks = 0\n//# sourceURL=webpack:///./engine/utils.js?")},/*!********************************************!*\
  !*** ./engine/matrix/svd-golub-reinsch.js ***!
  \********************************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst Matrix  = __webpack_require__(/*! ./matrix */ 3);\n\nfunction pythag(a, b) {\n  var absa = Math.abs(a)\n    , absb = Math.abs(b);\n\n  return (absa > absb\n          ? absa * Math.sqrt(1 + Math.pow(absb/absa, 2))\n          : (absb === 0 ? 0 : absb*Math.sqrt(1 + Math.pow(absa/absb, 2))));\n}\n\n/**\n * Translation of the SVD algorithm published in Numer. Math. 14, 403-420 (1970)\n * by G. H. Golub and C. Reinsch.\n *\n * Source: http://cs.brown.edu/courses/csci0530/current/homeworks/svd.py\n *\n * @param {Matrix<m,n>} A Matrix to decompose (m >= n)\n * @return {[Matrix<m,m>, Matrix<m,n>, Matrix<n,n>]} [U, E, V] s.t. A = U*E*V\n */\nfunction svd(A) {\n  var eps = Number.EPSILON\n    , tol = Number.MIN_VALUE / eps;\n\n  if (1.0 + eps <= 1.0) {\n    throw new Error('Make eps bigger');\n  }\n  if (tol <= 0.0) {\n    throw new Error('Make tol bigger');\n  }\n\n  var itmax = 50\n    , u = A.clone()\n    , m = u.shape[0]\n    , n = u.shape[1]\n    , e = []\n    , q = []\n    , v = new Matrix(n, n)\n    , g = 0.0\n    , x = 0.0\n    , i, j, k, l, s, f, h, y, iteration, gotoTestFConvergence, z, c, l1;\n\n  if (m < n) {\n    throw new Error('m is less than n');\n  }\n\n  for (i = 0; i < n; i++) {\n    e[i] = g;\n    s = 0.0;\n    l = i + 1;\n    for (j = i; j < m; j++) s += u.data[j*n+i]*u.data[j*n+i];\n    if (s < tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i*n+i];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f*g-s;\n      u.data[i*n+i] = f-g;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = i; k < m; k++) s += u.data[k*n+i]*u.data[k*n+j];\n        f = s/h;\n        for (k = i; k < m; k++) u.data[k*n+j] = u.data[k*n+j] + f*u.data[k*n+i];\n      }\n    }\n    q[i] = g;\n    s = 0.0;\n    for (j = l; j < n; j++) s = s + u.data[i*n+j]*u.data[i*n+j];\n    if (s <= tol) {\n      g = 0.0;\n    } else {\n      f = u.data[i*n+i+1];\n      if (f < 0.0) {\n        g = Math.sqrt(s);\n      } else {\n        g = -Math.sqrt(s);\n      }\n      h = f*g - s;\n      u.data[i*n+i+1] = f-g;\n      for (j = l; j < n; j++) e[j] = u.data[i*n+j]/h;\n      for (j = l; j < m; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s = s + (u.data[j*n+k]*u.data[i*n+k]);\n        for (k = l; k < n; k++) u.data[j*n+k] = u.data[j*n+k]+(s*e[k]);\n      }\n    }\n    y = Math.abs(q[i]) + Math.abs(e[i]);\n    if (y > x) {\n      x = y;\n    }\n  }\n  // accumulation of right hand transformations\n  for (i = n-1; i > -1; i--) {\n    if (g !== 0) {\n      h = g*u.data[i*n+i+1];\n      for (j = l; j < n; j++) v.data[j*n+i] = u.data[i*n+j]/h;\n      for (j = l; j < n; j++) {\n        s = 0.0;\n        for (k = l; k < n; k++) s += (u.data[i*n+k]*v.data[k*n+j]);\n        for (k = l; k < n; k++) v.data[k*n+j] += (s*v.data[k*n+i]);\n      }\n    }\n    for (j = l; j < n; j++) {\n      v.data[i*n+j] = 0.0;\n      v.data[j*n+i] = 0.0;\n    }\n    v.data[i*n+i] = 1.0;\n    g = e[i];\n    l = i;\n  }\n  // accumulation of left hand transformations\n  for (i = n-1; i > -1; i--) {\n    l = i+1;\n    g = q[i];\n    for (j = l; j < n; j++) u.data[i*n+j] = 0.0;\n    if (g !== 0.0) {\n      h = u.data[i*n+i]*g;\n      for (j = l; j < n; j++)  {\n        s = 0.0;\n        for (k = l; k < m; k++) s += (u.data[k*n+i]*u.data[k*n+j]);\n        f = s/h;\n        for (k = i; k < m; k++) u.data[k*n+j] += (f*u.data[k*n+i]);\n      }\n      for (j = i; j < m; j++) u.data[j*n+i] = u.data[j*n+i] / g;\n    } else {\n      for (j = i; j < m; j++) u.data[j*n+i] = 0.0;\n    }\n    u.data[i*n+i] += 1.0;\n  }\n  // diagonalization of the bidiagonal form\n  eps = eps*x;\n  for (k = n-1; k > -1; k--) {\n    for (iteration = 0; iteration < itmax; iteration++) {\n      // test f splitting\n      for (l = k; l > -1; l--) {\n        gotoTestFConvergence = false;\n        if (Math.abs(e[l]) <= eps) {\n          // goto test f convergence\n          gotoTestFConvergence = true;\n          break;\n        }\n        if (Math.abs(q[l-1]) <= eps) {\n          // goto cancellation\n          break;\n        }\n      }\n      if (!gotoTestFConvergence) {\n        // cancellation of e[l] if l>0\n        c = 0.0;\n        s = 1.0;\n        l1 = l-1;\n        for (i = l; i < k+1; i++) {\n          f = s*e[i];\n          e[i] = c*e[i];\n          if (Math.abs(f) <= eps) {\n            // goto test f convergence\n            break;\n          }\n          g = q[i];\n          h = pythag(f, g);\n          q[i] = h;\n          c = g/h;\n          s = -f/h;\n          for (j = 0; j < m; j++) {\n            y = u.data[j*n+l1];\n            z = u.data[j*n+i];\n            u.data[j*n+l1] = y*c+z*s;\n            u.data[j*n+i] = -y*s+z*c;\n          }\n        }\n      }\n      // test f convergence\n      z = q[k];\n      if (l === k) {\n        // convergence\n        if (z < 0.0) {\n          // q[k] is made non-negative\n          q[k] = -z;\n          for (j = 0; j < n; j++) {\n            v.data[j*n+k] = -v.data[j*n+k];\n          }\n        }\n        break; // break out of iteration loop and move on to next k value\n      }\n      if (iteration >= itmax-1) {\n        throw new Error('SVD: No convergence');\n      }\n      // shift from bottom 2x2 minor\n      x = q[l];\n      y = q[k-1];\n      g = e[k-1];\n      h = e[k];\n      f = ((y-z)*(y+z)+(g-h)*(g+h))/(2.0*h*y);\n      g = pythag(f, 1.0);\n      if (f < 0) {\n        f = ((x-z)*(x+z)+h*(y/(f-g)-h))/x;\n      } else {\n        f = ((x-z)*(x+z)+h*(y/(f+g)-h))/x;\n      }\n      // next QR transformation\n      c = 1.0;\n      s = 1.0;\n      for (i = l+1; i < k+1; i++) {\n        g = e[i];\n        y = q[i];\n        h = s*g;\n        g = c*g;\n        z = pythag(f,h);\n        e[i-1] = z;\n        c = f/z;\n        s = h/z;\n        f = x*c+g*s;\n        g = -x*s+g*c;\n        h = y*s;\n        y = y*c;\n        for (j = 0; j < n; j++) {\n          x = v.data[j*n+i-1];\n          z = v.data[j*n+i];\n          v.data[j*n+i-1] = x*c+z*s;\n          v.data[j*n+i] = -x*s+z*c;\n        }\n        z = pythag(f, h);\n        q[i-1] = z;\n        c = f/z;\n        s = h/z;\n        f = c*g+s*y;\n        x = -s*g+c*y;\n        for (j = 0; j < m; j++) {\n          y = u.data[j*n+i-1];\n          z = u.data[j*n+i];\n          u.data[j*n+i-1] = y*c+z*s;\n          u.data[j*n+i] = -y*s+z*c;\n        }\n      }\n      e[l] = 0.0;\n      e[k] = f;\n      q[k] = x;\n      // goto test f splitting\n    }\n  }\n\n  return [u, q, v];\n}\n\nmodule.exports = svd;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/svd-golub-reinsch.js\n// module id = 5\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/svd-golub-reinsch.js?")},/*!********************************!*\
  !*** ./engine/matrix/lstsq.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst Matrix  = __webpack_require__(/*! ./matrix */ 3);\nconst svd     = __webpack_require__(/*! ./svd-golub-reinsch */ 5);\nconst dist    = __webpack_require__(/*! ./distributions-socr */ 7);\n\n/**\n * Computes total least squares regression on the matrix `A`, already decomposed\n * using SVD into the constituent `U`, `S` (sigma), and `V` matrices.\n *\n * @param {Matrix<m,n>} A Data matrix\n * @param {Matrix<m,m>} U U matrix resulting from SVD\n * @param {Matrix<m,n>} S Diagonal sigma matrix resulting from SVD\n * @param {Matrix<n,n>} V V matrix resulting from SVD\n * @param {Matrix<m,1>} b Independent column\n * @return {Matrix<n,1>} Estimated weight vector for the parameters (cols) in A\n */\nfunction lstsqSVD(A, U, S, V, b) {\n  var s = S\n    , m = A.shape[0]\n    , n = A.shape[1]\n    , eps = Number.EPSILON\n    , efcols = []\n    , maxEig = Math.max.apply(null, s.data)\n    , i, d, x;\n\n  for (i = 0; i < n; i++) {\n    if (s.data[i] < Math.max(m, n)*eps*maxEig) {\n      s.data[i] = 0;\n    }\n  }\n  d = U.T.dot(b);\n  d = d.dotDivide(s);\n  for (i = 0; i < n; i++) {\n    if (Math.abs(d.data[i]) === Infinity) {\n      d.data[i] = 0;\n    }\n  }\n  x = V.dot(d);\n  return x;\n}\n\n/**\n * Compute least squares regression using normal equations, then compute\n * analytical statistics to determine the quality of the fit for the model and\n * for each term in the model.\n *\n *    B'      = inv(X'X)X'y                       <-- weight vector\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSR / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i = B' / sqrt( inv(X'X)[i,i] * MSE )      / is element-wise\n *\n * @return {object} Regression results\n */\nfunction lstsqNEWithStats(X, y) {\n  var XT            = X.T\n    , pseudoInverse = XT.dot(X).inv()\n    , BHat          = pseudoInverse.dot(XT).dot(y)\n    , yHat          = X.dot(BHat)\n\n  // fit statistics\n    , nd            = X.shape[0]\n    , np            = X.shape[1]\n    , sse           = y.sub(yHat).dotPow(2).sum()\n    , tss           = y.sub(y.sum() / y.shape[0]).dotPow(2).sum()\n    , ssr           = tss - sse\n    , vary          = tss / (nd - 1)\n    , msr           = ssr / (np - 1)\n    , mse           = sse / (nd - np)\n    , rsq           = 1 - (sse / tss)\n    , crsq          = 1 - rsq\n    , adjrsq        = 1 - (mse / vary)\n    , f             = msr / mse\n    , aic           = Math.log10(mse) + 2*(np / nd)\n    , bic           = Math.log10(mse) + np*(Math.log10(nd) / nd)\n\n  // for t-statistics\n    , rtmse         = Math.sqrt(mse)\n    , sec           = pseudoInverse.diag().abs().dotPow(0.5).dotMultiply(rtmse)\n    , tstats        = BHat.dotDivide(sec)\n    , pts           = tstats.clone();\n\n  pts.data.set(pts.data.map((t) => dist.pt(t, nd - np)));\n\n  return {\n    weights : BHat,\n    tstats  : tstats,\n    mse     : mse,\n    rsq     : rsq,\n    crsq    : crsq,\n    adjrsq  : adjrsq,\n    f       : f,\n    pf      : dist.pf(f, np, nd - np),\n    aic     : aic,\n    bic     : bic,\n    pts     : pts\n  };\n}\n\n/**\n * Compute least squares regression using singular value decomposition, then\n * compute analytical statistics to determine the quality of the fit for the\n * model and for each term in the model.\n *\n *    U, s, V = svd(X)\n *    B'      = V(U'b ./ s)                       See svd.lstsq for more\n *    y'      = XB'\n *\n *    Nd      = # of data\n *    Np      = # of params (coefs) in model\n *\n *    SSE     = sum((y - y')^2)                   ^2 is element-wise\n *    TSS     = sum((y - mean(y))^2)\n *    SSR     = TSS - SSE\n *    Var y   = TSS / (Nd - 1)\n *    MSR     = SSM / (Np - 1)\n *    MSE     = SSE / (Nd - Np)\n *    RSQ     = 1 - (SSE / TSS)\n *    cRSQ    = 1 - R^2\n *    adj-RSQ = 1 - (MSE / Var y)\n *    F       = MSR / MSE\n *    AIC     = log(MSE) + 2*(Np/Nd)\n *    BIC     = log(MSE) + Np*log(Nd)/Nd\n *    t_i     = it's complicated...see code\n *\n * @return {object} Regression results\n */\nfunction lstsqSVDWithStats(X, y, predictors) {\n  var decomposition = svd(X)\n    , U             = decomposition[0]\n    , w             = Matrix.from(decomposition[1])\n    , V             = decomposition[2]\n    , BHat          = predictors || lstsqSVD(X, U, w, V, y)\n    , yHat          = X.dot(BHat)\n\n  // fit statistics\n    , nd            = X.shape[0]\n    , np            = X.shape[1]\n    , sse           = y.sub(yHat).dotPow(2).sum()\n    , tss           = y.sub(y.sum() / y.shape[0]).dotPow(2).sum()\n    , ssr           = tss - sse\n    , vary          = tss / (nd - 1)\n    , msr           = ssr / (np - 1)\n    , mse           = sse / (nd - np)\n    , rsq           = 1 - (sse / tss)\n    , crsq          = 1 - rsq\n    , adjrsq        = 1 - (mse / vary)\n    , f             = msr / mse\n    , aic           = Math.log10(mse) + 2*(np / nd)\n    , bic           = Math.log10(mse) + np*(Math.log10(nd) / nd)\n\n  // used for t-stat calculations\n    , VdivwSq       = V.dotDivide(w).dotPow(2)\n    , i;\n\n  for (i = 0; i < VdivwSq.data.length; i += 1) {\n    if (Math.abs(VdivwSq.data[i]) === Infinity || isNaN(VdivwSq.data[i])) {\n      VdivwSq.data[i] = 0;\n    }\n  }\n\n  var sec = new Matrix(1, X.shape[1])\n    , stdModelErr;\n\n  for (i = 0; i < X.shape[1]; i += 1) {\n    stdModelErr = Math.sqrt(VdivwSq.row(i).sum() * mse);\n    sec.data[i] = stdModelErr;\n  }\n\n  var tstats        = BHat.dotDivide(sec);\n  var pts           = tstats.clone();\n\n  pts.data.set(pts.data.map((t) => dist.pt(t, nd - np)));\n\n  return {\n    weights: BHat,\n    pf: dist.pf(f, np, nd - np),\n    f: Math.abs(f),\n    tstats, mse, rsq, crsq, adjrsq, aic, bic, pts\n  };\n}\n\nmodule.exports.lstsqSVD = lstsqSVDWithStats;\nmodule.exports.lstsqNE  = lstsqNEWithStats;\n\nvar a = Matrix.from([[41.9, 29.1],\n                     [43.4, 29.3],\n                     [43.9, 29.5],\n                     [44.5, 29.7],\n                     [47.3, 29.9],\n                     [47.5, 30.3],\n                     [47.9, 30.5],\n                     [50.2, 30.7],\n                     [52.8, 30.8],\n                     [53.2, 30.9],\n                     [56.7, 31.5],\n                     [57.0, 31.7],\n                     [63.5, 31.9],\n                     [65.3, 32.0],\n                     [71.1, 32.1],\n                     [77.0, 32.5],\n                     [77.8, 32.9]]);\nvar b = new Matrix(17, 1, [251.3, 251.3, 248.3, 267.5,\n                           273.0, 276.5, 270.3, 274.9,\n                           285.0, 290.0, 297.0, 302.5,\n                           304.5, 309.3, 321.7, 330.7,\n                           349.0]);\n\n\nvar a = new Matrix([[22,10, 2,  3, 7],\n                    [14, 7,10,  0, 8],\n                    [-1,13,-1,-11, 3],\n                    [-3,-2,13, -2, 4],\n                    [ 9, 8, 1, -2, 4],\n                    [ 9, 1,-7,  5,-1],\n                    [ 2,-6, 6,  5, 1],\n                    [ 4, 5, 0, -2, 2]]);\nvar b = new Matrix(8, 1, [12, 5, -2, -7, 1, 3, 10, 3]);\n\n// taylorfit's Bhat\n//var tfguess = Matrix.from([1.79903, 6.11149]).T;\nvar tfguess = Matrix.from([0.308165, 0.0720651, -0.0893553, 0.602561, 0.210042]).T;\n\n// rms test\nvar rms = [];\nvar ndf = a.shape[0] - 2;\nfor (var i = 0; i < a.shape[1]; i += 1) {\n  rms.push(a.col(i).abs().sum() / ndf);\n}\n\n/*\nrms = Matrix.from(rms);\nvar anorm = a.dotDivide(rms);\nvar bnorm = b.dotDivide(b.abs().sum() / ndf);\n\nconsole.log('rms', rms);\nvar estNE = lstsqNEWithStats(a, b);\nvar estSVD = lstsqSVDWithStats(a, b);\n\nconsole.log('ne  B:', estNE.weights.T);\nconsole.log('svd B:', estSVD.weights.T);\n\nconsole.log('ne  T:', estNE.tstats.T);\nconsole.log('svd T:', estSVD.tstats.T);\nconsole.log('realB:', tfguess.T);\n\nconsole.log(Math.sqrt(a.dot(estSVD.weights).dotMultiply(-1).add(b).dotPow(2).sum()));\nconsole.log(Math.sqrt(a.dot(tfguess).dotMultiply(-1).add(b).dotPow(2).sum()));\nconsole.log();\n\nconsole.log('       [ actual   , my guess , taylorfit ]');\nconsole.log('       -----------------------------------');\nconsole.log(b.hstack(a.dot(estSVD.weights)).hstack(a.dot(tfguess)));\n */\n\n\n/*\nconsole.log('NE  MSE:', estNE.mse);\nconsole.log('SVD MSE:', estSVD.mse);\nconsole.log();\nconsole.log('NE  Ts:');\nconsole.log(estNE.tstats.toString());\nconsole.log('SVD Ts:');\nconsole.log(estSVD.tstats.toString());\nconsole.log('NE  B:');\nconsole.log(estNE.weights.toString());\nconsole.log('SVD B:');\nconsole.log(estSVD.weights.toString());\n*/\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/lstsq.js\n// module id = 6\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/lstsq.js?")},/*!*********************************************!*\
  !*** ./engine/matrix/distributions-socr.js ***!
  \*********************************************/
function(module,exports){eval("'use strict';\n\n\nfunction statcom(q, i, j, b) {\n  var zz = 1\n    , z = zz\n    , k = i;\n\n  while (k <= j) {\n    zz *= q * k / (k-b);\n    z += zz;\n    k += 2;\n  }\n  return z;\n}\n\n\n/**\n * Two sided T-distribution estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} t T-statistic for some independent variable\n * @param {Number} n Degrees of freedom\n * @return {Number} 2-tailed p-value for the t statistic ( Pr(t) )\n */\nfunction pt(t, n) {\n  t = Math.abs(t);\n\n  var w = t / Math.sqrt(n)\n    , th = Math.atan(w);\n\n  if (n === 1) {\n    return 1 - th / (Math.PI / 2);\n  }\n\n  var sth = Math.sin(th)\n    , cth = Math.cos(th);\n\n  if ((n % 2) === 1) {\n    return 1 - (th + sth * cth * statcom(cth*cth, 2, n-3, -1)) / (Math.PI / 2);\n  }\n  return 1 - sth * statcom(cth*cth, 1, n-3, -1);\n}\n\n\n/**\n * Fisher's F-density estimator.\n *\n * Source: https://github.com/SOCR/HTML5_WebSite\n *         (Applets/Normal_T_Chi2_F_Tables.html)\n * License: GNU LGPL\n *\n * @param {Number} f  F value for the model\n * @param {Number} n1 # of terms in the model\n * @param {Number} n2 Degrees of freedom\n * @return {Number} Probability of (F < f)\n */\nfunction pf(f, n1, n2) {\n  var x = n2/(n1*f+n2);\n\n  if ((n1 % 2) === 0) {\n    return statcom(1-x, n2, n1+n2-4, n2-2) * Math.pow(x, n2/2);\n  }\n  if ((n2 % 2) === 0) {\n    return 1 - statcom(x, n1, n1+n2-4, n1-2) * Math.pow(1-x, n1/2);\n  }\n\n  var th = Math.atan(Math.sqrt(n1*f/n2))\n    , a = th / (Math.PI / 2)\n    , sth = Math.sin(th)\n    , cth = Math.cos(th);\n\n  if (n2 > 1) {\n    a += sth * cth * statcom(cth*cth, 2, n2-3, -1) / (Math.PI / 2);\n  }\n  if (n1 === 1) {\n    return 1 - a;\n  }\n\n  var c = 4 * statcom(sth*sth, n2+1, n1+n2-4, n2-2)\n            * sth * Math.pow(cth, n2) / Math.PI;\n\n  if (n2 === 1) {\n    return 1 - a + c / 2;\n  }\n\n  var k = 2;\n\n  while (k <= (n2-1)/2) {\n    c *= k/(k-0.5);\n    k += 1;\n  }\n  return 1 - a + c;\n}\n\nmodule.exports.pt = pt;\nmodule.exports.pf = pf;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/matrix/distributions-socr.js\n// module id = 7\n// module chunks = 0\n//# sourceURL=webpack:///./engine/matrix/distributions-socr.js?")},/*!************************************!*\
  !*** ./engine/observable/index.js ***!
  \************************************/
function(module,exports,__webpack_require__){eval("\nmodule.exports = __webpack_require__(/*! ./Observable */ 9);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/observable/index.js\n// module id = 8\n// module chunks = 0\n//# sourceURL=webpack:///./engine/observable/index.js?")},/*!*****************************************!*\
  !*** ./engine/observable/Observable.js ***!
  \*****************************************/
function(module,exports){eval("\nconst _events         = Symbol('events');\nconst _listeners      = Symbol('listeners');\nconst _listenerCount  = Symbol('listenerCount');\n\nclass Observable {\n\n  constructor() {\n    this[_events] = {};\n    this[_listeners] = {};\n    this[_listenerCount] = 0;\n  }\n\n  on(event, handler) {\n    let id = this[_listenerCount] += 1;\n\n    this[_listeners][id] = handler;\n\n    if (!this[_events][event]) {\n      this[_events][event] = [];\n    }\n\n    this[_events][event].push(id);\n    return id;\n  }\n\n  removeListener(id) {\n    delete this[_listeners][id];\n\n    Object.keys(this[_events]).forEach(\n      (event) => this[_events][event] = this[_events][event].filter(\n        (handlerId) => handlerId !== id));\n  }\n\n  fire(event, data) {\n    if (!this[_events][event]) {\n      this[_events][event] = [];\n    }\n    this[_events][event].forEach((id) => this[_listeners][id](data));\n  }\n\n}\n\nmodule.exports = Observable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/observable/Observable.js\n// module id = 9\n// module chunks = 0\n//# sourceURL=webpack:///./engine/observable/Observable.js?")},/*!**********************************!*\
  !*** ./engine/model/termpool.js ***!
  \**********************************/
function(module,exports,__webpack_require__){eval("\nconst Term  = __webpack_require__(/*! ./term */ 11);\nconst md5   = __webpack_require__(/*! blueimp-md5 */ 12);\n\nclass TermPool {\n\n  constructor(model) {\n    this.model = model;\n    this.terms = {};\n  }\n\n  get(term) {\n    let found = this.terms[Term.hash(term)];\n\n    if (!found) {\n      found = new Term(this.model, term);\n      this.terms[Term.hash(found.valueOf())] = found;\n    }\n\n    return found;\n  }\n\n  clearCache() {\n    Object.values(this.terms).forEach((term) => term.clearCache());\n  }\n\n}\n\n\nmodule.exports = TermPool;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/termpool.js\n// module id = 10\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/termpool.js?")},/*!******************************!*\
  !*** ./engine/model/term.js ***!
  \******************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst lstsq   = __webpack_require__(/*! ../matrix */ 2).lstsq;\nconst Matrix  = __webpack_require__(/*! ../matrix */ 2).Matrix;\nconst bi_md5  = __webpack_require__(/*! blueimp-md5 */ 12);\n\nconst md5     = (x) => bi_md5(x);\n\n\n/**\n * Private members\n *\n * @private\n */\nconst _parts  = Symbol('parts');\nconst _model  = Symbol('model');\nconst _cache  = Symbol('cache');\n\n\n/**\n * Term is a combination of input columns and exponents, such as x^2*y^3.\n *\n * @class Term\n */\nclass Term {\n\n  /**\n   * Creates a new Term.\n   *\n   * @constructor\n   * @param {Model}             model         Model that owns this Term\n   * @param {[num, num, num][]} parts         List of triples of numbers\n   * @param {number}            parts[i][0]   First is the index of a column\n   * @param {number}            parts[i][1]   Second is the exponent to raise\n   *                                          that column to\n   * @param {number}           [parts[i][2]]  Third is the lag to apply to that\n   *                                          column\n   */\n  constructor(model, parts) {\n    if (!parts.every(Array.isArray)) {\n      throw new TypeError('Part does not match: [col, exp (,lag)]');\n    }\n\n    this[_parts] = parts.map((part) => {\n      if (part.length < 2) {\n        throw new TypeError('Part does not match: [col, exp (,lag)]');\n      }\n      if (part.length < 3) {\n        return part.concat(0);\n      }\n      return part.slice();\n    });\n\n    this[_model] = model;\n\n    this[_cache] = { col: {} };\n    this.col();\n  }\n\n  /**\n   * Computes least squares regression and analysis statistics on the parent\n   * model PLUS this term.\n   *\n   * @return {t: number, mse: number} Statistics for the regression\n   */\n  getStats(subset=this[_model].DEFAULT_SUBSET) {\n    let lag = Math.max(this[_model].highestLag(), this.lag)\n      , XLagged = this[_model].X(subset).hstack(this.col(subset)).lo(lag)\n      , yLagged = this[_model].y(subset).lo(lag)\n      , theStats;\n\n    try {\n      theStats = lstsq(XLagged, yLagged);\n      theStats.coeff = theStats.weights.get(0, theStats.weights.shape[0]-1);\n      theStats.t = theStats.tstats.get(0, theStats.tstats.shape[0]-1);\n      theStats['p(t)'] = theStats.pts.get(0, theStats.pts.shape[0]-1);\n      theStats['p(f)'] = theStats.pf;\n      delete theStats.weights;\n      delete theStats.tstats;\n      delete theStats.pts;\n      delete theStats.pf;\n\n      return theStats;\n\n      // XXX: Obsolete\n      /*\n      return {\n        coeff : theStats.weights.get(0, theStats.weights.shape[0]-1),\n        t     : theStats.tstats.data[[theStats.tstats.shape[0] - 1]],\n        mse   : theStats.mse\n      };\n       */\n    } catch (e) {\n      console.error(e);\n      return NaN;\n    }\n  }\n\n  clearCache() {\n    this[_cache].col = {};\n    return this;\n  }\n\n  /**\n   * Determines if this term is equivalent to `other`.\n   *\n   * @param {Term | [num, num, num][]}  other Term to compare against\n   * @return {boolean} True if the terms are equivalent, false otherwise\n   */\n  equals(other) {\n    other = other.valueOf();\n    return Term.hash(other) === Term.hash(this);\n  }\n\n  /**\n   * Returns the information necessary to reconstruct the term in a plain\n   * object (except the reference to the model).\n   *\n   * @return {[num, num, num][]} List of [col, exp, lag] triples\n   */\n  valueOf() {\n    return this[_parts].slice();\n  }\n\n  /**\n   * Compute the data column for a given matrix.\n   *\n   * @return {Matrix<n,1>} n x 1 Matrix -- polynomial combo of columns in term\n   */\n  col(subset=this[_model].DEFAULT_SUBSET) {\n    if (this[_cache].col[subset] != null) {\n      return this[_cache].col[subset];\n    }\n\n    let data = this[_model].data(subset)\n      , prod = Matrix.zeros(data.shape[0], 1).add(1)\n      , i;\n\n    for (i = 0; i < this[_parts].length; i += 1) {\n      prod = prod.dotMultiply(\n        data.col(this[_parts][i][0])\n          .dotPow(this[_parts][i][1])\n          .shift(this[_parts][i][2]));\n    }\n\n    this[_cache].col[subset] = prod;\n\n    return this[_cache].col[subset];\n  }\n\n  get lag() {\n    return Math.max.apply(null, this[_parts].map((part) => part[2]));\n  }\n\n  /**\n   * Give a representation of the term in a pretty format.\n   *\n   * @return {string} Representation of this term\n   */\n  inspect(depth, options) {\n    return 'Term < ' + this[_parts]\n      .map((t) => String.fromCharCode(t[0] + 97)\n           + '^' + t[1]\n           + '[' + t[2] + ']')\n      .join(' * ') + ' >';\n  }\n\n  static hash(term) {\n    term = term.valueOf().map((part) => {\n      if (part.length < 2) {\n        throw new TypeError('Part does not match: [col, exp (,lag)]');\n      }\n      if (part.length < 3) {\n        return part.concat(0);\n      }\n      return part.slice();\n    });\n\n    return md5(term.map(md5).sort().join());\n  }\n\n}\n\nmodule.exports = Term;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/term.js\n// module id = 11\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/term.js?")},/*!*********************************!*\
  !*** ./~/blueimp-md5/js/md5.js ***!
  \*********************************/
function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n;(function ($) {\n  'use strict'\n\n  /*\n  * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n  * to work around bugs in some JS interpreters.\n  */\n  function safeAdd (x, y) {\n    var lsw = (x & 0xFFFF) + (y & 0xFFFF)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xFFFF)\n  }\n\n  /*\n  * Bitwise rotate a 32-bit number to the left.\n  */\n  function bitRotateLeft (num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /*\n  * These functions implement the four basic operations the algorithm uses.\n  */\n  function md5cmn (q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  function md5ff (a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | ((~b) & d), a, b, x, s, t)\n  }\n  function md5gg (a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & (~d)), a, b, x, s, t)\n  }\n  function md5hh (a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  function md5ii (a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | (~d)), a, b, x, s, t)\n  }\n\n  /*\n  * Calculate the MD5 of an array of little-endian words, and a bit length.\n  */\n  function binlMD5 (x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << (len % 32)\n    x[(((len + 64) >>> 9) << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /*\n  * Convert an array of little-endian words to a string\n  */\n  function binl2rstr (input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF)\n    }\n    return output\n  }\n\n  /*\n  * Convert a raw string to an array of little-endian words\n  * Characters >255 have their high-byte silently ignored.\n  */\n  function rstr2binl (input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32)\n    }\n    return output\n  }\n\n  /*\n  * Calculate the MD5 of a raw string\n  */\n  function rstrMD5 (s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /*\n  * Calculate the HMAC-MD5, of a key and some data (raw strings)\n  */\n  function rstrHMACMD5 (key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5C5C5C5C\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /*\n  * Convert a raw string to a hex string\n  */\n  function rstr2hex (input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0F) +\n      hexTab.charAt(x & 0x0F)\n    }\n    return output\n  }\n\n  /*\n  * Encode a string as utf-8\n  */\n  function str2rstrUTF8 (input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /*\n  * Take string arguments and return either raw or hex encoded strings\n  */\n  function rawMD5 (s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  function hexMD5 (s) {\n    return rstr2hex(rawMD5(s))\n  }\n  function rawHMACMD5 (k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  function hexHMACMD5 (k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  function md5 (string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n      return md5\n    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else if (typeof module === 'object' && module.exports) {\n    module.exports = md5\n  } else {\n    $.md5 = md5\n  }\n}(this))\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/blueimp-md5/js/md5.js\n// module id = 12\n// module chunks = 0\n//# sourceURL=webpack:///./~/blueimp-md5/js/md5.js?")},/*!********************************!*\
  !*** ./engine/model/combos.js ***!
  \********************************/
function(module,exports,__webpack_require__){eval("'use strict';\n\nconst utils = __webpack_require__(/*! ../utils */ 4);\n\n/**\n * Generate all combinations of k terms.\n *\n * @param {*[]}     terms         Array of items to combine\n * @param {number}  k             # of items in every combination\n * @param {boolean} [replacement] If true, an item from `terms` can be repeated\n *                                in a single combination\n */\nlet combinations = function(terms, k, replacement) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n  if (k === 1) {\n    return terms.map((term) => [term]);\n  }\n\n  for (i = 0; i < terms.length; i += 1) {\n    var subCombos = combinations(\n      // with replacements    => slice at i (include the current term)\n      // without replacements => slice at i + 1 (exclude current term)\n      terms.slice(i + !replacement),\n      k - 1,\n      replacement\n    );\n    // prepend the current term to each sub combo\n    combos = combos.concat(subCombos.map((combo) => [terms[i]].concat(combo)));\n  }\n  return combos;\n};\n\n/**\n * Generates all combinations of k items using one item from each bin in `bins`.\n *\n *    bins = [[0, 1], [2, 3]], k = 2\n *  ->[[0, 2], [0, 3], [1, 2], [1, 3]]\n *\n *\n * @param {*[][]} bins  An array of arrays containing items. For each\n *                      combination, only one item from each bin can be present\n * @return {*[][]} Combos\n */\nlet combinationsFromBins = function(bins, k) {\n  var combos = [];\n  var i;\n\n  if (k < 1) {\n    return combos;\n  }\n  if (bins.length <= 0) {\n    return combos;\n  }\n  if (k === 1) {\n    return utils.join(bins).map((term) => [term]);\n  }\n  for (i = 0; i < bins[0].length; i += 1) {\n    var subCombos = combinationsFromBins(bins.slice(1), k - 1);\n    combos = combos.concat(subCombos.map((combo) => [bins[0][i]].concat(combo)));\n  }\n  return combos.concat(combinationsFromBins(bins.slice(1), k));\n};\n\n/**\n * Generates all possible combinations of exponentiated terms given a list of\n * exponents, a list of # of multiplicands, and a list of lags\n *\n * @param {number[]}  features    Independent column indices from the original\n *                                dataset\n * @param {number[]}  exponents   Array of exponents ([1, 2] means x, x^2)\n * @param {number[]}  multipliers Array of # of multiplicands ([1] means only\n *                                one multiplicand per term)\n * @param {number[]}  lags        Array of # of multiplicands ([1] means only\n *                                one multiplicand per term)\n * @return {[number, number][][]} List of terms\n */\nlet generateTerms = function(features, exponents, multipliers, lags) {\n  var bins = features.map(\n    (i) => utils.join(exponents.map(\n      (e) => [0].concat(lags).map(\n        (l) => [i, e, l]))))\n\n    , combosForMults = utils.join(multipliers.map(\n      (m) => combinationsFromBins(bins, m)));\n\n  return combosForMults;\n};\n\nmodule.exports.generateTerms = generateTerms;\nmodule.exports.combinations = combinations;\nmodule.exports.combinationsFromBins = combinationsFromBins;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./engine/model/combos.js\n// module id = 13\n// module chunks = 0\n//# sourceURL=webpack:///./engine/model/combos.js?")}]);